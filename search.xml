<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>开发环境：使用 Ruby 工具链统一开发环境</title>
      <link href="/posts/470af619.html"/>
      <url>/posts/470af619.html</url>
      
        <content type="html"><![CDATA[<h1 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h1><p>在iOS开发过程中，你是否常常遇到这些挑战：</p><p>每次启动新项目，都需要手动设置开发环境；有时，在安装第三方工具时需要<code>sudo</code>权限，这导致以后每次安装工具都需要手动输入密码，无法实现自动化。另外，每当启动新的CI服务时，都需要手动登录和配置一遍。更令人头疼的是，随着<code>Xcode</code>版本的更新，已经配置好的CI服务也需要重新设置。</p><p>为何会如此麻烦呢？主要是因为在项目初始阶段未能做好统一配置。</p><p>所谓统一配置，即将所有配置信息以文本格式存放在<code>Git</code>中。这样，我们随时可以查看修改记录，帮助我们比较不同配置之间的差异，从而不断更新迭代。</p><p>有了统一配置，任何工程师都能搭建出一模一样的开发环境，构建功能一致的<code>App</code>。此外，统一配置还使我们能够根据需求扩展<code>CI</code>服务，无需手动操作。更重要的是，统一配置还可以应用到其他类似的<code>iOS</code>项目中，极大地减轻了项目启动阶段的搭建成本。</p><h1 id="二、Ruby-工具链"><a href="#二、Ruby-工具链" class="headerlink" title="二、Ruby 工具链"></a>二、Ruby 工具链</h1><p>我们可以利用<code>Ruby</code>工具链为整个项目建立一致的开发和构建环境。为何选择<code>Ruby</code>而非其他语言呢？因为在<code>iOS</code>开发领域，目前流行的第三方工具<code>CocoaPods</code>和<code>fastlane</code>都是用<code>Ruby</code>开发的。特别值得一提的是，<code>Ruby</code>拥有成熟的依赖库管理工具<code>RubyGems</code>和<code>Bundler</code>，后者能有效地管理<code>CocoaPods</code>和<code>fastlane</code>的版本。</p><p>这种选择带来了几个重要的优势：</p><ol><li>生态系统的兼容性：由于<code>CocoaPods</code>和<code>fastlane</code>等主要工具是用<code>Ruby</code>开发的，因此使用<code>Ruby</code>可以确保与这些工具的生态系统兼容性，减少潜在的兼容性问题。</li><li>成熟的依赖管理工具：<code>RubyGems</code>和<code>Bundler</code>是非常成熟的依赖管理工具，能够轻松地管理项目所需的各种库和工具的版本，从而确保开发环境的一致性。</li><li>易于学习和使用：<code>Ruby</code>语言相对简单易学，因此使用Ruby作为开发环境配置工具的语言，可以降低团队成员学习成本，提高开发效率。</li></ol><p>总的来说，选择<code>Ruby</code>作为项目的开发环境配置工具语言，是基于其与<code>iOS</code>开发生态系统的高度集成以及<code>Ruby</code>本身成熟的依赖管理工具。这样可以确保项目的开发环境与流行的<code>iOS</code>开发工具保持一致，并提高团队的开发效率。</p><p><img src="/images/20240409/Snipaste_2024-04-10_01-27-50.png" alt="开发环境统一配置图"></p><p>通常情况下，确保统一的开发环境应从操作系统开始。对于<code>iOS</code>开发而言，<code>macOS</code>是唯一支持的操作系统。在公司环境中，<code>macOS</code>的版本通常由IT部门统一管理和更新。需要注意的是，当公司更新了我们开发环境所需的<code>macOS</code>版本时，必须同时更新CI服务器上的<code>macOS</code>版本，以确保一致性。</p><p>这种关注操作系统版本一致性的做法至关重要，因为：</p><ol><li><p>开发环境一致性：统一的操作系统版本可以确保团队成员在相同的开发环境中工作，避免因为版本差异而产生的问题。</p></li><li><p>支持和兼容性：<code>iOS</code>开发需要依赖于特定版本的<code>Xcode</code>和其他开发工具。确保CI服务器上的<code>macOS</code>版本与开发环境一致，可以保证CI过程中的兼容性和稳定性。</p></li><li><p>减少配置和调试时间：如果开发环境和<code>CI</code>服务器上的<code>macOS</code>版本不一致，可能会导致一些与操作系统相关的问题，需要花费额外的时间来调试和解决。一致的操作系统版本可以减少这种情况的发生，提高开发效率。</p></li></ol><p>因此，确保开发环境和<code>CI</code>服务器上的<code>macOS</code>版本保持一致是保障团队协作和项目顺利进行的重要步骤。</p><h1 id="三、Xcode"><a href="#三、Xcode" class="headerlink" title="三、Xcode"></a>三、Xcode</h1><p>位于 <code>macOS</code> 上层的是 <code>Xcode</code> 和 <code>rbenv</code>。其中，Xcode是<code>iOS</code>开发和构建的主要工具。在同一个项目中，最好使用相同版本的<code>Xcode</code>进行开发和构建，以确保一致性。我们可以在项目的<code>README.md</code>文件中注明所使用的<code>Xcode</code>版本。</p><p>为了保证团队成员都安装同一个版本的<code>Xcode</code>，要到有自动更新功能的 <code>Mac App Store </code>中下载 <code>Xcode</code>，而是到<a href="https://developer.apple.com/download/all/">苹果的开发者网站</a>搜索并下载。</p><p>有时候，我们需要安装不同版本<code>Xcode</code>开发维护不同版本的<code>Xcode</code>创建的项目。所以本机有可能安装多个版本的<code>Xcode</code>,此时需要特别注意，为了保证所使用的编译器版本一致，在每次执行自动化命令之前（如执行<code>bundle exec fastlane test</code>），要先使用<code>xcode-select -s</code>来选择该项目所对应版本的 <code>Xcode</code>。<br>比如：在开发 Test App 时，因为需要本机安装了多个App，所以每次执行自动化命令之前都会执行<code>xcode-select -s /Applications/Xcode14.app/Contents/Developer</code>来选择 <code>Test App </code>项目所使用的 <code>Xcode</code>。这里的<code>Xcode14.app</code>就是我安装的<code> Xcode 14</code> 版所在的位置。</p><h1 id="四、rbenv"><a href="#四、rbenv" class="headerlink" title="四、rbenv"></a>四、rbenv</h1><h2 id="4-1安装-Ruby-版本管理工具"><a href="#4-1安装-Ruby-版本管理工具" class="headerlink" title="4.1安装 Ruby 版本管理工具"></a>4.1安装 Ruby 版本管理工具</h2><p>确保Xcode版本一致后，由于后续将使用到<code>CocoaPods</code>等第三方Ruby工具，因此整个项目团队必须保持一致的<code>Ruby</code>版本。为实现自动化安装和管理这些工具，我们需要使用<code>Ruby</code>环境管理工具。</p><p>目前流行的<code>Ruby</code>环境管理工具包括<code>RVM</code>和<code>rbenv</code>。推荐使用<code>rbenv</code>，因为它利用<code>shims</code>文件夹来分离各个<code>Ruby</code>版本，相比<code>RVM</code>更轻便易用。但务必注意，团队内部不应同时使用不同的<code>Ruby</code>环境管理工具，否则可能导致项目编译错误。</p><p><code>rbenv</code>是一款<code>Ruby</code>环境管理工具，能够安装、管理、隔离以及在多个Ruby版本之间进行切换。我们可以通过<code>Homebrew</code>来安装rbenv。以下是安装<code>Homebrew</code>和<code>rbenv</code>的脚本：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/bin/bash -c &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)&quot;</span><br><span class="line"></span><br><span class="line">brew install rbenv ruby-build rbenv-vars</span><br></pre></td></tr></table></figure><p>安装完<code>rbenv</code>后，我们需要将以下设置信息添加到你的<code>Shell</code>配置文件中，例如<code>~/.bash_profile</code>或<code>~/.zshrc</code>等文件。这样可以确保每次打开终端时都会初始化<code>rbenv</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 设置 rbenv 环境变量</span><br><span class="line">export PATH=&quot;$HOME/.rbenv/bin:$PATH&quot;</span><br><span class="line"></span><br><span class="line"># 初始化 rbenv</span><br><span class="line">eval &quot;$(rbenv init -)&quot;</span><br></pre></td></tr></table></figure><h2 id="4-2-安装和设置项目的-Ruby-环境"><a href="#4-2-安装和设置项目的-Ruby-环境" class="headerlink" title="4.2 安装和设置项目的 Ruby 环境"></a>4.2 安装和设置项目的 Ruby 环境</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ cd $(PROJECT_DIR)</span><br><span class="line">$ rbenv install 3.2.1</span><br><span class="line">$ rbenv local 3.2.1</span><br></pre></td></tr></table></figure><p>在这里，我们将项目的<code>Ruby</code>环境配置为<code>3.2.1</code>版本。<code>rbenv</code>会为我们创建一个名为<code>.ruby-version</code>的文件，该文件只包含一个版本号（例如3.2.1）的字符串。这个包含版本号的文件可以被Git进行管理。如果需要更新版本，可以通过<code>rbenv local</code>命令进行，每次更新也由<code>Git</code>统一管理，这样就能确保其他团队成员使用相同版本的<code>Ruby</code>开发环境。</p><h1 id="五、RubyGems-和-Bundler"><a href="#五、RubyGems-和-Bundler" class="headerlink" title="五、RubyGems 和 Bundler"></a>五、RubyGems 和 Bundler</h1><p><code>RubyGems</code> 和 <code>Bundler</code> 主要是用来安装和管理 <code>CocoaPods</code> 和 <code>fastlane</code> 等第三方工具。</p><p><code>RubyGems</code>是<code>Ruby</code>的依赖包管理工具，<code>Ruby</code>世界中的包被称为<code>Gem</code>。我们可以使用<code>gem install</code>命令来安装<code>Gem</code>。然而，<code>RubyGems</code>在管理<code>Gem</code>版本时存在一些不足之处，因此有人开发了<code>Bundler</code>。<code>Bundler</code>可以检查和安装<code>Gem</code>的特定版本，为<code>Ruby</code>项目提供一致性的环境。</p><p>要安装<code>Bundler</code>，可以执行<code>gem install bundler</code>命令。然后，执行<code>bundle init</code>命令可以生成一个<code>Gemfile</code>文件。在这个文件中，像<code>CocoaPods</code>和<code>fastlane</code>等依赖包就可以被添加进去。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">source &quot;https://rubygems.org&quot;</span><br><span class="line">gem &quot;cocoapods&quot;, &quot;1.15.2&quot;</span><br><span class="line">gem &quot;fastlane&quot;, &quot;2.220.0&quot;</span><br></pre></td></tr></table></figure><p>注意我们在gem命令里面都指定了依赖包的特定版本号。例如，在我们的 <code>Test App</code> 就使用了<code>1.15.2</code>版的 <code>CocoaPods</code>，然后执行<code>bundle install</code>来安装各个 <code>Gem</code>。 <code>Bundler</code> 会自动生成一个 <code>Gemfile.lock</code> 文件来锁定所安装的 <code>Gem</code> 的版本，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">DEPENDENCIES</span><br><span class="line">  cocoapods (= 1.15.2)</span><br><span class="line">  fastlane (= 2.220.0)</span><br></pre></td></tr></table></figure><p>为了保证团队其他成员都可以使用版本号一致的 <code>Gem</code>，我们需要把 <code>Gemfile</code> 和<code> Gemfile.lock</code> 一同保存到 <code>Git</code> 里面统一管理起来。</p><p>到此为止，我们已经知道怎样使用 <code>Ruby</code> 工具链配置一个统一的开发环境。但在真实的开发环境中，搭建环境只需要一个人来完成即可，其他成员执行以下脚本就能完成整套开发环境的搭建。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># ./scripts/setup.sh</span><br><span class="line"></span><br><span class="line"># Install ruby using rbenv</span><br><span class="line">ruby_version=`cat .ruby-version`</span><br><span class="line">if [[ ! -d &quot;$HOME/.rbenv/versions/$ruby_version&quot; ]]; then</span><br><span class="line">  rbenv install $ruby_version;</span><br><span class="line">fi</span><br><span class="line"># Install bunlder</span><br><span class="line">gem install bundler</span><br><span class="line"># Install all gems</span><br><span class="line">bundle install</span><br><span class="line"># Install all pods</span><br><span class="line">bundle exec pod install</span><br></pre></td></tr></table></figure><p>该脚本主要做了四件事情，第一步是在 <code>rbenv</code> 下安装特定版本的 <code>Ruby</code> 开发环境，然后通过 RubyGems 安装 Bunlder，接着使用 <code>Bundler</code> 安装 <code>CocoaPods</code> 和 <code>fastlane</code> 等依赖包，最后安装各个 <code>Pod</code>。这样，一个统一的项目环境就搭建完成了</p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 开发环境 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用SwiftUI开发安卓App</title>
      <link href="/posts/380d7a3e.html"/>
      <url>/posts/380d7a3e.html</url>
      
        <content type="html"><![CDATA[<h1 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h1><p>是的！你没看错真的是用 Swift 开发原生安卓App，已经有开发者研究出<br>使用 SwiftUI 开发安卓App，并且出了尝鲜版，今天就来介绍一下 Skip 的框架，并且通过 Skip 框架使用 SwiftUI 开发安卓APP。</p><h1 id="二、安装-Skip"><a href="#二、安装-Skip" class="headerlink" title="二、安装 Skip"></a>二、安装 Skip</h1><h2 id="2-1-系统要求"><a href="#2-1-系统要求" class="headerlink" title="2.1 系统要求"></a>2.1 系统要求</h2><p>MacOS: 13+<br>Xcode: 15+<br>Android Studio: 2023</p><h2 id="2-2-安装"><a href="#2-2-安装" class="headerlink" title="2.2 安装"></a>2.2 安装</h2><p>使用  Homebrew 安装 Skip，如果没有 Homebrew ，请先安装，</p><p>Homebrew 官网：<a href="https://brew.sh/">https://brew.sh/</a></p><p>打开终端，运行Terminal命令安装Skip:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install skiptools/skip/skip</span><br></pre></td></tr></table></figure><blockquote><p>这行命令将下载并安装<code>skip</code>工具本身，以及构建和测试<code>Kotlin/Android</code>端应用程序所需的<code>gradle</code>和<code>JDK </code>依赖项。</p></blockquote><p>安装完成后，运行下面命令检查是否满足开发先决条件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">skip checkup</span><br></pre></td></tr></table></figure><p>如果<code>checkup</code>失败，执行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">skip checkup --verbose</span><br></pre></td></tr></table></figure><p>以获取更多详细信息，并查看<a href="https://skip.tools/docs/faq/">FAQ</a>以获取常见解决方案。</p><p>如果<code>checkup</code>通过。</p><p><img src="https://assets.skip.tools/intro/skip_checkup.png" alt="skip checkup"></p><p>如上图显示，那就可以开始使用Skip进行开发了!</p><h1 id="三、创建-App"><a href="#三、创建-App" class="headerlink" title="三、创建 App"></a>三、创建 App</h1><p>打开终端，用命令创建一个双平台应用项目：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">skip init --appid=bundle.id project-name AppName</span><br></pre></td></tr></table></figure><p>通过<code>--open-xcode</code>参数可以立即在Xcode中打开项目。例如:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">skip init --open-xcode --appid=com.xyz.HelloSkip hello-skip HelloSkip</span><br></pre></td></tr></table></figure><p>创建成功后它会自动打开 <code>Xcode</code> 以启动这个项目，在本地创建一个 <code>hello-skip/ </code>文件夹，其中包含一个新的 <code>SwiftPM</code> 包，其中包含一个名为 <code>HelloSkip</code> 的模块，以及名为 <code>Darwin</code> 和 <code>Android</code> 的文件夹以及共享 <code>Skip.env</code> 应用配置文件。该 <code>Darwin</code> 文件夹将包含一个 <code>HelloSkip.xcodeproj</code>的项目，可以在 <code>Xcode</code> 中打开。</p><h1 id="四、创建并打开-Android-模拟器"><a href="#四、创建并打开-Android-模拟器" class="headerlink" title="四、创建并打开 Android 模拟器"></a>四、创建并打开 Android 模拟器</h1><p>启动 <code>Android Studio</code> 并打开 <code>Virtual Device Manager</code> 创建一个新的模拟器（例如，“<code>Pixel 6</code>”），然后启动这个模拟器：</p><p><img src="https://assets.skip.tools/intro/device_manager.png" alt="创建安卓模拟器"></p><h1 id="五、运行项目"><a href="#五、运行项目" class="headerlink" title="五、运行项目"></a>五、运行项目</h1><p>一旦Android模拟器开始运行，在Xcode中选择并运行HelloSkip目标。第一次构建将花费一些时间来编译Skip库，并且可能会提示您一个对话框，以确认您信任Skip插件。</p><p>一旦构建和运行操作完成，SwiftUI应用程序将在选定的iOS模拟器中打开，同时编译的应用程序将在当前运行的Android模拟器中启动。</p><p><img src="https://assets.skip.tools/intro/skip_xcode.png" alt="运行项目"></p><p>现在，就可以在 <code>Xcode</code> 中，直接使用 <code>SwiftUI</code> 开发<code>iOS + Andorid</code>项目。</p><p>更多 <code>Skip</code> 相关，请访问官网了解：<a href="https://skip.tools/">https://skip.tools/</a></p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SwiftUI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Flutter 的性能分析和监控</title>
      <link href="/posts/e6652508.html"/>
      <url>/posts/e6652508.html</url>
      
        <content type="html"><![CDATA[<h1 id="一、devTools-的使用"><a href="#一、devTools-的使用" class="headerlink" title="一、devTools 的使用"></a>一、devTools 的使用</h1><p>devTools 是官方出的一套 Dart 和 Flutter 的性能调试工具，其核心是帮开发者定位 UI 或者 GPU 线程问题，从而协助开发者解决 Flutter App 的性能问题。在应用该工具之前，需要启动 App 调试功能。</p><p>打开 Flutter 项目，如果使用的是 Android Studio IDE，可以直接在工具栏中点击如下图所示的红色圈部分。<br><img src="/images/20230819/20230819001.png"></p><p>如果不是在 Android Studio 中，需要按照下面的四个步骤启动 devTools 工具。</p><p>1.使用下面命令启动 devTools 工具。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flutter pub global run devtools</span><br></pre></td></tr></table></figure><p>2.运行成功后，会提示 devTools 访问的地址。打开访问地址后，可以看到如下图的界面，界面中需要输入一个 Flutter App 的监听地址。</p><p><img src="/images/20230819/20230819002.png"></p><p>3.接下来需要获取 Flutter 运行的 WS 地址，重新运行项目（请注意不是热启动，需要停止运行，然后点击重新运行），启动成功后，在运行栏可以看到如下所示的信息。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Launching lib/main.dart on iPhone 14 Pro Max in debug mode...</span><br><span class="line">Running Xcode build...</span><br><span class="line">Xcode build done.     </span><br><span class="line">Debug service listening on ws://127.0.0.1:51667/M2Fw4v3rtAc=/ws</span><br><span class="line">Syncing files to device iPhone 14 Pro Max...</span><br></pre></td></tr></table></figure><p>4.将其中的 listening on 的地址输入到刚才 devTools 页面就可以了，打开页面后，可以看到下图所示的功能。</p><p><img src="/images/20230819/20230819003.png"></p><p>接下来介绍下 devTools 功能，即上图中每个工具的作用。</p><ul><li><strong>Flutter Inspector</strong>，可以查看组件的布局信息，类似于前端的 Chrome 工具的 CSS 布局查看器，应用该功能可以快速定位布局问题。</li><li><strong>Timeline</strong>，时间线事件图表，跟踪显示来自应用程序的所有事件。监听 Flutter App 在构建 UI 树，绘制界面以及其他（例如 HTTP 流量）事件等，并将监听到的事件所花费的时间，显示在时间轴上。</li><li><strong>Memory</strong>，使用时间线的方式，展示 Flutter App 的内存变化，通过该工具可以定位内存泄漏的问题。</li><li><strong>Performance</strong>，性能分析工具，可以通过录制界面操作，获取界面性能数据。该工具的主要用途还是在定位某个功能卡顿问题，例如我们发现主界面很卡顿，这时候就可以通过该工具录制首页加载过程，然后分析出具体性能异常逻辑。</li><li><strong>Debugger</strong>，断点调试功能，和 IDE 上的断点调试是一样的。</li><li><strong>Network</strong>，可以抓取网络请求，并分析返回数据，类似于前端 Chrome 的 Network 工具。</li><li><strong>Logging</strong>，运行期间的日志显示。日志中包含：Dart 运行时的垃圾回收事件、Flutter 框架事件，比如创建帧的事件、应用的 stdout 和 stderr 和应用的自定义日志事件。</li></ul><h2 id="1-1-应用-Timeline-来做性能分析和优化"><a href="#1-1-应用-Timeline-来做性能分析和优化" class="headerlink" title="1.1 应用 Timeline 来做性能分析和优化"></a>1.1 应用 Timeline 来做性能分析和优化</h2><p>Timeline 会记录每一帧的绘制，每一帧绘制又包括 UI 线程构建图形树和 GPU 线程绘制图像两个过程。在应用开发完成后，我们可以使用 Timeline 工具来走一遍 App 所有页面，记录每一帧的性能耗时。请注意该功能最好是在外接实体机上进行测试，不然会出现数据相差较大。我们分为以下七个步骤来进行实践。</p><ol><li>连接实体调试机器，然后运行 flutter run –profile 启动 App。</li><li>打开 devTools 工具，点击 Timeline 工具，点击 Clear 清空旧数据。</li><li>可以在某个页面上进行一系列的基础操作，操作完成后，回到 devTools 中，点击 Refresh，这时候会有一个短暂的分析过程，分析完成后，你会看到下图所示的内容。<img src="/images/20230819/20230819004.png" alt="Timeline 性能柱状图"></li><li>在界面中，你会看到浅蓝（ UI 线程耗时，小于 16.67ms）、深蓝（ GPU 耗时，小于 16.67 ms）、橘黄（ UI 线程耗时，大于 16.67 ms）和深红（ GPU 耗时，大于 16.67 ms）的柱状数据，浅蓝和橘黄都代表 UI 线程耗时，深蓝和深红都代表 GPU 耗时，在 UI 线程耗时和 GPU 耗时都小于 16.67 ms 时显示浅蓝和深蓝，而当 UI 线程耗时或者 GPU 耗时任意一个大于 16.67 ms 时，则显示橘黄和深红。</li><li>当发现有橘黄和深红的柱状图时，则需要进行具体的分析，这时候只需要点击这部分柱状图，就可以看到下图所示的一个效果。<img src="/images/20230819/20230819005.png" alt="Timeline 单个数据分析图"></li><li>如果 UI 线程耗时比较长，点击具体较长的柱状图，可以看到具体的火焰图。如下图所示，其中的宽度就代表执行的时间长度，宽度越长表明性能损耗越大，而这就是性能优化的部分。<img src="/images/20230819/20230819006.png" alt="UI 线程耗时分析"></li><li>如果 GPU 耗时较长，则可以往下拉查看 GPU 页面绘制问题，如下图所示。<img src="/images/20230819/20230819007.png" alt="GPU 耗时分析"></li></ol><p>接下来我们就分别从 UI 线程问题和 GPU （ Raster ）来分析具体的性能问题。</p><h2 id="1-2-UI-线程问题实践分析"><a href="#1-2-UI-线程问题实践分析" class="headerlink" title="1.2 UI 线程问题实践分析"></a>1.2 UI 线程问题实践分析</h2><p>如果出现橘黄色和深红色的柱状图时，我们需要单独分析这块的性能问题。大部分情况是因为在 Dart 中执行了比较耗时的函数，或者在组件树设计上没有注意性能导致的问题。这里介绍下可能会提升或者影响性能的几个关键点。</p><ul><li>不会发生任何变化的组件，使用 const ，减少绘制，例如我们的通用 loading 组件。</li><li>减少组件绘制，这点就是我们之前提到的尽量减少有状态组件下的子组件，或者通过状态管理模块 Provider 来辅助管理状态。</li><li>复杂业务 build 函数在代码逻辑中，避免复杂业务在 build 逻辑中去执行。</li></ul><h2 id="1-3-GPU（-Raster-）"><a href="#1-3-GPU（-Raster-）" class="headerlink" title="1.3 GPU（ Raster ）"></a>1.3 GPU（ Raster ）</h2><p>一般情况下都是较复杂的图片绘制产生的问题，比如说复杂的动效或者复杂的图片资源。上面的工具也不能完全帮你定位到异常的问题。需要根据实际的代码逻辑来分析，这点是比较困难的，只能排除法步步寻找问题点。Timeline 图只能协助我们去找到 GPU 存在性问题。</p><p>在遇到 GPU 问题时，可以在 devTools 中的 Performance 打开 Performance Overlay 工具，打开后在真机或者虚拟机上就可以看到效果，当出现 GPU 性能问题时，会出现红色线条。<br><img src="/images/20230819/20230819008.png" alt="Performance Overlay"></p><p>以上就是 devTools 的工具使用，通过这个工具可以大大提升我们定位问题的效率。</p><h1 id="二、性能上报"><a href="#二、性能上报" class="headerlink" title="二、性能上报"></a>二、性能上报</h1><p>为了能够更好地分析和判断性能问题，我们有时候需要采集现网运行期间的一些性能数据，例如我们需要主要的两个指标：Crash 率和 FPS 数据。接下来我们主要介绍下如何计算和采集这两个数据的方法。</p><p>由于这部分肯定会影响主线程的性能，因此我们将该计算和上报过程放入到一个新的线程去处理，避免影响主线程。这里就需要用到Isolate 线程进行双向的通信；</p><h2 id="2-1-Crash-率"><a href="#2-1-Crash-率" class="headerlink" title="2.1 Crash 率"></a>2.1 Crash 率</h2><p>异常率的计算方法是需要根据手机机型和手机版本来进行分析，我们先制定如下数据指标：</p><ul><li>机型的 Crash 率 &#x3D; 机型的 Crash 量 &#x2F; 该机型页面访问量</li><li>版本的 Crash 率 &#x3D; 版本的 Crash 量 &#x2F; 该版本页面的访问量</li><li>版本机型的 Crash 率 &#x3D; 机型版本的 Crash 量 &#x2F; 该机型特定版本的访问量</li></ul><p>根据上面的计算方式，我们需要增加一些数据上报，主要包括：机型、版本、页面名称、Crash 情况。</p><h2 id="2-2-FPS"><a href="#2-2-FPS" class="headerlink" title="2.2 FPS"></a>2.2 FPS</h2><p>计算 FPS 的逻辑相对来说较复杂一些，首先需要使用 Flutter 的 SchedulerBinding.instance.addTimingsCallback 函数来获取每一帧耗时，这段代码主要是在 Flutter 绘制完成每一帧后都会进行回调处理，通过回调的方式可以采集到每一帧的耗时信息，具体代码逻辑如下：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// <span class="language-markdown">启动监听数据 </span></span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> start() <span class="keyword">async</span>&#123; </span><br><span class="line">  deviceInfo = <span class="keyword">await</span> IsolateHandle.getDeviceInfo(); </span><br><span class="line">  SchedulerBinding.instance.addTimingsCallback( </span><br><span class="line">      Report.onReportTimings </span><br><span class="line">  ); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在 onReportTimings 中将每一帧数据分别保存到 frames 和 routerFrames ，代码如下：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// <span class="language-markdown">数据处理 </span></span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> onReportTimings(<span class="built_in">List</span>&lt;FrameTiming&gt; timings) &#123; </span><br><span class="line">  <span class="keyword">for</span> (FrameTiming timing <span class="keyword">in</span> timings) &#123; </span><br><span class="line">    frames.addFirst(timing); </span><br><span class="line">    routerFrames.addFirst(timing); </span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>routerFrames 为当前页面路由的帧耗时的队列，frames 为所有帧耗时的队列。有了绘制的每一帧数据后，我们再将数据传递到其他线程进行计算，这里会传递到 IsolateHandle 的 calculateFps 方法，我们具体看下这个方法的计算逻辑。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// <span class="language-markdown">计算当个页面的 fps </span></span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> isolateCalculateFps( </span><br><span class="line">    ListQueue&lt;FrameTiming&gt; calculateList, </span><br><span class="line">    <span class="built_in">String</span> routerName, </span><br><span class="line">    <span class="built_in">String</span> deviceInfo </span><br><span class="line">    ) &#123; </span><br><span class="line">  <span class="keyword">if</span>(calculateList == <span class="keyword">null</span>)&#123; </span><br><span class="line">    <span class="keyword">return</span>; </span><br><span class="line">  &#125; </span><br><span class="line">  <span class="built_in">String</span> fpsStr = <span class="number">60.</span>toStringAsFixed(<span class="number">3</span>); </span><br><span class="line">  <span class="built_in">int</span> lostNum = <span class="number">0</span>; </span><br><span class="line">  <span class="comment">// flutter 标准渲染频率 </span></span><br><span class="line">  <span class="built_in">double</span> standardFps = <span class="number">1000</span>/<span class="number">60</span>; </span><br><span class="line">  <span class="comment">// 计算多少出现掉帧情况，请注意如果是 33秒，其掉帧为2，用34/16。67下取整。 </span></span><br><span class="line">  calculateList.forEach((frame) &#123; </span><br><span class="line">    <span class="keyword">if</span>(frame.totalSpan.inMilliseconds &gt; standardFps) &#123; <span class="comment">// 超出 16ms 的帧 </span></span><br><span class="line">      lostNum = lostNum + ( </span><br><span class="line">          frame.totalSpan.inMilliseconds/standardFps </span><br><span class="line">      ).floor(); </span><br><span class="line">    &#125; </span><br><span class="line">  &#125;); </span><br><span class="line">  <span class="keyword">if</span>(calculateList.length + lostNum &gt; <span class="number">0</span>) &#123; <span class="comment">// 尽量避免分母为0情况 </span></span><br><span class="line">    <span class="built_in">double</span> fps = ( <span class="number">60</span> * calculateList.length ) / </span><br><span class="line">        ( calculateList.length + lostNum ); </span><br><span class="line">    fpsStr = fps.toStringAsFixed(<span class="number">3</span>); </span><br><span class="line">  &#125; </span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&#x27;<span class="subst">$&#123;deviceInfo&#125;</span>\t<span class="subst">$&#123;fpsStr&#125;</span>&#x27;</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码中，首先获取标准的一帧绘制时间 16.67 ms（目前这部分是hardcode 60 HZ，后续需要匹配 120 HZ），然后分别计算每一帧的渲染耗时情况，并与 16.67 ms 进行对比，得到掉帧数量。计算掉帧的方式是，用耗时时间除以 16.67 ms 下取整就代表掉帧数量。比如耗时 34 ms，代表掉帧了 2 帧，因为 34 &#x2F; 16.67 &#x3D; 2.039。最后用以下公式来计算 FPS 。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(list.length * <span class="number">60</span>) / (list.length + lostNum)</span><br></pre></td></tr></table></figure><p>FPS 和 PV 一样将数据上报到服务端，后续在服务端进行分析。</p><p>以上就完成了所有的性能上报功能，接下来我们在某个页面进行尝试，这里选择之前侧边栏的“单图片信息”。</p><h2 id="2-3-应用"><a href="#2-3-应用" class="headerlink" title="2.3 应用"></a>2.3 应用</h2><p>在该类中的 initState 中上报 PV ，并在页面开始加载前，将帧放入到具体的 routerFrames 中，代码如下：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@override</span> </span><br><span class="line"><span class="keyword">void</span> initState() &#123; </span><br><span class="line">  <span class="keyword">super</span>.initState(); </span><br><span class="line">  <span class="comment">/// <span class="language-markdown">开始记录fps </span></span></span><br><span class="line">  Report.startRecord(<span class="string">&#x27;<span class="subst">$&#123;<span class="keyword">this</span>.runtimeType&#125;</span>&#x27;</span>); </span><br><span class="line">  indexPos = <span class="number">0</span>; </span><br><span class="line">  <span class="comment">// 拉取推荐内容 </span></span><br><span class="line">  ApiContentIndex.getRecommendList().then((retInfo) &#123; </span><br><span class="line">    <span class="keyword">if</span> (retInfo.ret != <span class="number">0</span>) &#123; </span><br><span class="line">      <span class="comment">// 判断返回是否正确 </span></span><br><span class="line">      <span class="keyword">return</span>; </span><br><span class="line">    &#125; </span><br><span class="line">    setState(() &#123; </span><br><span class="line">      contentList = retInfo.data; </span><br><span class="line">    &#125;); </span><br><span class="line">  &#125;); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中<code>Report.startRecord(&#39;$&#123;this.runtimeType&#125;&#39;); </code>就是上报 PV ，并开始记录 routerFrames ，这里通过 this.runtimeType 可以获得具体的类名。FPS 则在页面最后一帧加载完成后回调，然后在回调中计算 FPS 相关数据。在 Flutter 提供了接收帧绘制完成后回调的方法，需要在 build 逻辑中增加下面的代码。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">WidgetsBinding.instance.addPostFrameCallback( </span><br><span class="line">        (_) =&gt; Report.endRecord(<span class="string">&#x27;<span class="subst">$&#123;<span class="keyword">this</span>.runtimeType&#125;</span>&#x27;</span>) </span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>然后在 Report.endRecord 调用其他线程函数，计算 FPS，并需要清空 routerFrames 。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// <span class="language-markdown">结束并显示数据 </span></span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> endRecord(<span class="built_in">String</span> routerName) &#123; </span><br><span class="line">  IsolateHandle.calculateFps(routerFrames, routerName, deviceInfo); </span><br><span class="line">  routerFrames.clear(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完成后就可以在虚拟机或者真机上进行模拟测试了，不过这里的 FPS 数据不一定完全准确，后续需要进一步优化。</p>]]></content>
      
      
      <categories>
          
          <category> Flutter </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 性能优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Flutter生命周期和使用场景</title>
      <link href="/posts/c21d8389.html"/>
      <url>/posts/c21d8389.html</url>
      
        <content type="html"><![CDATA[<p>在说 Flutter 生命周期前，先介绍一下 Flutter 的组件，然后是组件的生命周期。</p><h1 id="一、组件-Widget"><a href="#一、组件-Widget" class="headerlink" title="一、组件 Widget"></a>一、组件 Widget</h1><p>一个 Flutter 组件，包含了组件的模板、样式和交互等内容，外部只要按照组件设定的属性、函数及事件处理等进行调用即可，完全不用考虑组件的内部实现逻辑。其中组件又包括无状态组件和有状态组件。</p><ul><li>无状态组件</li></ul><p>无状态组件，可以理解为将外部传入的数据转化为界面展示的内容，只会渲染一次。</p><ul><li>有状态组件</li></ul><p>有状态组件，是定义交互逻辑和业务数据，可以理解为具有动态可交互的内容界面，会根据数据的变化进行多次渲染。</p><h1 id="二、生命周期"><a href="#二、生命周期" class="headerlink" title="二、生命周期"></a>二、生命周期</h1><p>在原生 Android 、原生 iOS 、前端 React 或者 Vue 都存在生命周期的概念，在 Flutter 中一样存在生命周期的概念，其基本概念和作用相似。 Flutter 中说的生命周期，也是指有状态组件，对于无状态组件生命周期只有 build 这个过程，也只会渲染一次，而有状态组件则比较复杂，下面我们就来看看有状态组件的生命周期过程。</p><h2 id="2-1-生命周期的流转"><a href="#2-1-生命周期的流转" class="headerlink" title="2.1 生命周期的流转"></a>2.1 生命周期的流转</h2><p>Flutter 中的生命周期，包含以下几个阶段：</p><ul><li><strong>createState</strong> ，该函数为 StatefulWidget 中创建 State 的方法，当 StatefulWidget 被调用时会立即执行 createState 。</li><li><strong>initState</strong> ，该函数为 State 初始化调用，因此可以在此期间执行 State 各变量的初始赋值，同时也可以在此期间与服务端交互，获取服务端数据后调用 setState 来设置 State。</li><li><strong>didChangeDependencies</strong> ，该函数是在该组件依赖的 State 发生变化时，这里说的 State 为全局 State ，例如语言或者主题等，类似于前端 Redux 存储的 State 。</li><li><strong>build</strong> ，主要是返回需要渲染的 Widget ，由于 build 会被调用多次，因此在该函数中只能做返回 Widget 相关逻辑，避免因为执行多次导致状态异常。</li><li><strong>reassemble</strong> ，主要是提供开发阶段使用，在 debug 模式下，每次热重载都会调用该函数，因此在 debug 阶段可以在此期间增加一些 debug 代码，来检查代码问题。</li><li><strong>didUpdateWidget</strong> ，该函数主要是在组件重新构建，比如说热重载，父组件发生 build 的情况下，子组件该方法才会被调用，其次该方法调用之后一定会再调用本组件中的 build 方法。</li><li><strong>deactivate</strong> ，在组件被移除节点后会被调用，如果该组件被移除节点，然后未被插入到其他节点时，则会继续调用 dispose 永久移除。</li><li><strong>dispose</strong> ，永久移除组件，并释放组件资源。</li></ul><p>生命周期流程图:<br><img src="/../images/20220807/20220807001.png"><br>整个过程分为四个阶段：</p><ol><li>初始化阶段，包括两个生命周期函数 createState 和 initState；</li><li>组件创建阶段，也可以称组件出生阶段，包括 didChangeDependencies 和 build；</li><li>触发组件多次 build ，这个阶段有可能是因为 didChangeDependencies、setState 或者 didUpdateWidget 而引发的组件重新 build ，在组件运行过程中会多次被触发，这也是优化过程中需要着重需要注意的点；</li><li>最后是组件销毁阶段，deactivate 和 dispose。</li></ol><h2 id="2-1-组件首次加载执行过程"><a href="#2-1-组件首次加载执行过程" class="headerlink" title="2.1 组件首次加载执行过程"></a>2.1 组件首次加载执行过程</h2><p>1、 在 lib 中 pages 下创建 test_stateful_widget.dart ；</p><p>2、 在 test_stateful_widget.dart 添加如下代码：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;package:flutter/material.dart&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// <span class="language-markdown">创建有状态测试组件</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestStatefulWidget</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  createState() &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;create state&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> TestState();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// <span class="language-markdown">创建状态管理类，继承状态测试组件</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">TestStatefulWidget</span>&gt; </span>&#123;</span><br><span class="line">  <span class="comment">/// <span class="language-markdown">定义 state [count] 计算器</span></span></span><br><span class="line">  <span class="built_in">int</span> count = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// <span class="language-markdown">定义 state [name] 为当前描述字符串</span></span></span><br><span class="line">  <span class="built_in">String</span> name = <span class="string">&#x27;test&#x27;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  initState() &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;init state&#x27;</span>);</span><br><span class="line">    <span class="keyword">super</span>.initState();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  didChangeDependencies() &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;did change dependencies&#x27;</span>);</span><br><span class="line">    <span class="keyword">super</span>.didChangeDependencies();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  didUpdateWidget(TestStatefulWidget oldWidget) &#123;</span><br><span class="line">    count++;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;did update widget&#x27;</span>);</span><br><span class="line">    <span class="keyword">super</span>.didUpdateWidget(oldWidget);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  deactivate() &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;deactivate&#x27;</span>);</span><br><span class="line">    <span class="keyword">super</span>.deactivate();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  dispose() &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;dispose&#x27;</span>);</span><br><span class="line">    <span class="keyword">super</span>.dispose();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  reassemble() &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;reassemble&#x27;</span>);</span><br><span class="line">    <span class="keyword">super</span>.reassemble();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// <span class="language-markdown">修改 state name</span></span></span><br><span class="line">  <span class="keyword">void</span> changeName() &#123;</span><br><span class="line">    setState(() &#123;</span><br><span class="line">      <span class="built_in">print</span>(<span class="string">&#x27;set state&#x27;</span>);</span><br><span class="line">      <span class="keyword">this</span>.name = <span class="string">&#x27;flutter&#x27;</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;build&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> Column(</span><br><span class="line">      children: &lt;Widget&gt;[</span><br><span class="line">        FlatButton(</span><br><span class="line">          child: Text(<span class="string">&#x27;<span class="subst">$name</span> <span class="subst">$count</span>&#x27;</span>), <span class="comment">// 使用 Text 组件显示描述字符和当前计算</span></span><br><span class="line">          onPressed: () =&gt; <span class="keyword">this</span>.changeName(), <span class="comment">// 点击触发修改描述字符 state name</span></span><br><span class="line">        )</span><br><span class="line">      ],</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码把有状态组件的一些生命周期函数都进行了重写，并且在执行中都打印了一些字符串标识，目的是可以看到该函数被执行。</p><p>运行程序，在输出控制台可以看到下面的运行打印日志信息。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">flutter: create state</span><br><span class="line">flutter: init state</span><br><span class="line">flutter: did change dependencies</span><br><span class="line">flutter: build</span><br><span class="line">flutter: reassemble</span><br><span class="line">flutter: did update widget</span><br><span class="line">flutter: build</span><br></pre></td></tr></table></figure><p>运行结果中，打印过程可以看到是按照我们上面图 1 的执行流程在运行的，但其中最值得关注的是 build 运行了两次。这是在开发模式下才会执行的过程，在正式环境是不会出现的，因为重新渲染成本非常大，这个问题可以使用打印 build 的调用堆栈即可发现。如果你要关闭两次 build 也可以实现，在 Flutter 框架中搜索 constants.dart 文件，并找到下面这行代码，将 defaultValue 从 false 修改为 true。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="built_in">bool</span> kReleaseMode = <span class="built_in">bool</span>.fromEnvironment(<span class="string">&#x27;dart.vm.product&#x27;</span>, defaultValue: <span class="keyword">true</span>);</span><br></pre></td></tr></table></figure><p>其实这里会触发 didUpdateWidget 函数，是因为 TestStatefulWidget 组件是 MyApp 组件中的子组件，从而导致 MyApp 函数中的 build 触发子组件 didUpdateWidget 函数的执行;</p>]]></content>
      
      
      <categories>
          
          <category> Flutter </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>WKWebView 白屏检测</title>
      <link href="/posts/66d3f26b.html"/>
      <url>/posts/66d3f26b.html</url>
      
        <content type="html"><![CDATA[<p>苹果放弃UIWebView后，公司项目已经全面采用高性能和高刷新的 WKWebView，但是加载网页过程中还是经常出现白屏的现象，且现有API协议捕获不到这种异常。造成用户体验极差。</p><p>针对业务场景需求，考虑采用字节跳动团队提出的 WebView 优化技术方案。在合适的加载时机对当前 WebView 可视区域截图，并对此快照进行像素点遍历，如果非白屏颜色的像素点超过一定的阈值，认定其为非白屏，反之重新加载请求。实现加载白屏检测。</p><p>代码实现：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"><span class="keyword">import</span> WebKit</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 检查 Web 是否白屏</span></span><br><span class="line"><span class="keyword">extension</span> <span class="title class_">WKWebView</span> &#123;</span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">WebLoadingStatus</span>&#123;</span><br><span class="line">        <span class="keyword">case</span> normal</span><br><span class="line">        <span class="keyword">case</span> error</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">judgeLoadingStatus</span>(<span class="params">webView</span>: <span class="type">WKWebView</span>?, <span class="params">completion</span>: ((<span class="keyword">_</span> status: <span class="type">WebLoadingStatus</span>) -&gt; <span class="type">Void</span>)<span class="operator">?</span>) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">#available</span>(<span class="keyword">iOS</span> <span class="number">11.0</span>, <span class="operator">*</span>) &#123;</span><br><span class="line">            <span class="keyword">guard</span> <span class="keyword">let</span> webView <span class="operator">=</span> webView <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">let</span> window <span class="operator">=</span> <span class="type">UIApplication</span>.shared.keyWindow</span><br><span class="line">            <span class="keyword">guard</span> <span class="keyword">let</span> window <span class="operator">=</span> window <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">let</span> webViewRect <span class="operator">=</span> webView.convert(webView.bounds, to: window)</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">let</span> shotConfiguration <span class="operator">=</span> <span class="type">WKSnapshotConfiguration</span>()</span><br><span class="line">            shotConfiguration.rect <span class="operator">=</span> <span class="type">CGRect</span>(x: webViewRect.origin.x, y: webViewRect.origin.y, width: webViewRect.size.width, height: webViewRect.size.height)</span><br><span class="line">            </span><br><span class="line">            webView.takeSnapshot(with: shotConfiguration) &#123; [<span class="keyword">weak</span> <span class="keyword">self</span>] (image, error) <span class="keyword">in</span></span><br><span class="line">                <span class="keyword">guard</span> <span class="keyword">let</span> <span class="keyword">self</span> <span class="operator">=</span> <span class="keyword">self</span>, <span class="keyword">let</span> image <span class="operator">=</span> image <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">let</span> scaleImage <span class="operator">=</span> <span class="keyword">self</span>.scaleImage(image: image)</span><br><span class="line">                <span class="keyword">let</span> isWhiteScreen <span class="operator">=</span> <span class="keyword">self</span>.searchEveryPixel(image: scaleImage)</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> isWhiteScreen &#123;</span><br><span class="line">                    completion<span class="operator">?</span>(.error)</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    completion<span class="operator">?</span>(.normal)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/// 遍历像素点，判断白色像素是否占比大于 95%</span></span><br><span class="line">    <span class="comment">/// - Parameter image: 图片</span></span><br><span class="line">    <span class="comment">/// - Returns: 占比</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">func</span> <span class="title function_">searchEveryPixel</span>(<span class="params">image</span>: <span class="type">UIImage</span>) -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> cgImage <span class="operator">=</span> image.cgImage</span><br><span class="line">        <span class="keyword">let</span> width: size_t <span class="operator">=</span> cgImage<span class="operator">?</span>.width <span class="operator">??</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">let</span> height: size_t <span class="operator">=</span> cgImage<span class="operator">?</span>.height <span class="operator">??</span> <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> dataProvider <span class="operator">=</span> cgImage<span class="operator">?</span>.dataProvider</span><br><span class="line">        <span class="keyword">let</span> data <span class="operator">=</span> dataProvider<span class="operator">?</span>.data</span><br><span class="line">        <span class="keyword">let</span> buffer: <span class="type">UnsafePointer</span>&lt;<span class="type">UInt8</span>&gt; <span class="operator">=</span> <span class="type">CFDataGetBytePtr</span>(data)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">var</span> whiteCount <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">var</span> totalCount <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> <span class="number">0</span> <span class="operator">..&lt;</span> height &#123;</span><br><span class="line">            <span class="keyword">for</span> y <span class="keyword">in</span> <span class="number">0</span> <span class="operator">..&lt;</span> width &#123;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">let</span> point <span class="operator">=</span> <span class="type">CGPoint</span>(x: x, y: y)</span><br><span class="line">                <span class="keyword">let</span> pixelInfo: <span class="type">Int</span> <span class="operator">=</span> (width <span class="operator">*</span> <span class="type">Int</span>(point.y)) <span class="operator">+</span> <span class="type">Int</span>(point.x) <span class="operator">*</span> <span class="number">4</span></span><br><span class="line">                </span><br><span class="line">                <span class="keyword">let</span> red <span class="operator">=</span> <span class="type">CGFloat</span>(buffer[pixelInfo])</span><br><span class="line">                <span class="keyword">let</span> green <span class="operator">=</span> <span class="type">CGFloat</span>(buffer[pixelInfo <span class="operator">+</span> <span class="number">1</span>])</span><br><span class="line">                <span class="keyword">let</span> blue <span class="operator">=</span> <span class="type">CGFloat</span>(buffer[pixelInfo <span class="operator">+</span> <span class="number">2</span>])</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> red <span class="operator">==</span> <span class="number">255.0</span> <span class="operator">&amp;&amp;</span> green <span class="operator">==</span> <span class="number">255.0</span> <span class="operator">&amp;&amp;</span> blue <span class="operator">==</span> <span class="number">255.0</span> &#123;</span><br><span class="line">                    whiteCount <span class="operator">+=</span> <span class="number">1</span></span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                totalCount <span class="operator">+=</span> <span class="number">1</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> proportion: <span class="type">CGFloat</span> <span class="operator">=</span> <span class="type">CGFloat</span>(whiteCount <span class="operator">/</span> totalCount)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> proportion <span class="operator">&gt;</span> <span class="number">0.95</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/// 缩放图片</span></span><br><span class="line">    <span class="comment">/// 为了提升检测性能，考虑将快照缩放至1/5，减少像素点总数，从而加快遍历速度</span></span><br><span class="line">    <span class="comment">/// - Parameter image: 原始图片</span></span><br><span class="line">    <span class="comment">/// - Returns: 缩放后图片</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">func</span> <span class="title function_">scaleImage</span>(<span class="params">image</span>: <span class="type">UIImage</span>) -&gt; <span class="type">UIImage</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> scale <span class="operator">=</span> <span class="number">0.2</span></span><br><span class="line">        <span class="comment">// 缩略图的尺寸在原图宽高 * 缩放系数后可能不是整数，在布置画布重绘时默认向上取整，这就造成画布比实际缩略图大</span></span><br><span class="line">        <span class="comment">// 造成不准确，所以此处选择 向下取整</span></span><br><span class="line">        <span class="keyword">let</span> newSize <span class="operator">=</span> <span class="type">CGSize</span>(width: floor(image.size.width <span class="operator">*</span> scale), height: floor(image.size.height <span class="operator">*</span> scale))</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">#available</span>(<span class="keyword">iOS</span> <span class="number">13.0</span>, <span class="operator">*</span>) &#123;</span><br><span class="line">            <span class="keyword">let</span> renderer <span class="operator">=</span> <span class="type">UIGraphicsImageRenderer</span>(size: newSize)</span><br><span class="line">            </span><br><span class="line">            renderer.image &#123; rendererContext <span class="keyword">in</span></span><br><span class="line">                <span class="keyword">return</span> image.draw(in: <span class="type">CGRect</span>(x: <span class="number">0</span>, y: <span class="number">0</span>, width: newSize.width, height: newSize.height))</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> image</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> WKWebView </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker常用命令</title>
      <link href="/posts/29dc6fe8.html"/>
      <url>/posts/29dc6fe8.html</url>
      
        <content type="html"><![CDATA[<h1 id="1、查询所有容器"><a href="#1、查询所有容器" class="headerlink" title="1、查询所有容器"></a>1、查询所有容器</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker images</span><br></pre></td></tr></table></figure><h1 id="2、查询docker正在运行容器"><a href="#2、查询docker正在运行容器" class="headerlink" title="2、查询docker正在运行容器"></a>2、查询docker正在运行容器</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps</span><br></pre></td></tr></table></figure><h1 id="3、启动所有容器"><a href="#3、启动所有容器" class="headerlink" title="3、启动所有容器"></a>3、启动所有容器</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker start $(docker ps -a | awk &#x27;&#123; print $1&#125;&#x27; | tail -n +2)</span><br></pre></td></tr></table></figure><h1 id="4、关闭所有容器"><a href="#4、关闭所有容器" class="headerlink" title="4、关闭所有容器"></a>4、关闭所有容器</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker stop $(docker ps -a | awk &#x27;&#123; print $1&#125;&#x27; | tail -n +2)</span><br></pre></td></tr></table></figure><h1 id="5、重启所有容器"><a href="#5、重启所有容器" class="headerlink" title="5、重启所有容器"></a>5、重启所有容器</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker restart $(docker ps -a -q)</span><br></pre></td></tr></table></figure><h1 id="6、删除所有容器"><a href="#6、删除所有容器" class="headerlink" title="6、删除所有容器"></a>6、删除所有容器</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rm $(docker ps -a | awk &#x27;&#123; print $1&#125;&#x27; | tail -n +2)</span><br></pre></td></tr></table></figure><h1 id="7、删除所有镜像"><a href="#7、删除所有镜像" class="headerlink" title="7、删除所有镜像"></a>7、删除所有镜像</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rmi $(docker images | awk &#x27;&#123;print $3&#125;&#x27; |tail -n +2)</span><br></pre></td></tr></table></figure><h1 id="8、强制删除所有镜像"><a href="#8、强制删除所有镜像" class="headerlink" title="8、强制删除所有镜像"></a>8、强制删除所有镜像</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rmi $(docker images | awk &#x27;&#123;print $3&#125;&#x27; |tail -n +2) --force</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用 Charles 进行抓包操作</title>
      <link href="/posts/feb46aa6.html"/>
      <url>/posts/feb46aa6.html</url>
      
        <content type="html"><![CDATA[<h1 id="一、Charles-工作原理"><a href="#一、Charles-工作原理" class="headerlink" title="一、Charles 工作原理"></a>一、Charles 工作原理</h1><p>下图是 Charles 官方网站上的一个 Charles 工作原理示意图。</p><p><img src="https://i0.wp.com/www.testeffective.com/wp-content/uploads/2017/02/request_response_flow.png"></p><p>由图可见，任何通过客户端（APP&#x2F;Web）发送给后端的请求，都将被 Charles 截获并转发给后端。同样，任何的后端返回值，也会经由 Charles 转发给客户端（APP&#x2F;Web）。</p><p>由此可见，Charles 的工作原理类似于中间人代理，即任何客户端和服务端的通信都会经过 Charles，于是 Charles 便可以拦截来自客户端和服务端的任何请求，并进行修改。</p><h1 id="二、搭建代理环境"><a href="#二、搭建代理环境" class="headerlink" title="二、搭建代理环境"></a>二、搭建代理环境</h1><p>首先去官网下载 Charles 并且安装。</p><p>下载地址：<a href="https://www.charlesproxy.com/">https://www.charlesproxy.com</a></p><h2 id="2-1-Web-端"><a href="#2-1-Web-端" class="headerlink" title="2.1 Web 端"></a>2.1 Web 端</h2><p>安装好 Charles 后， 首先去安装根证书。根证书的位置在 Help–&gt; SSL Proxying –&gt; Install Charles Root Certificate。<br><img src="/images/20210618/20210618001.png"></p><p>证书安装后，点击 Charles 的菜单， 选择 Proxy–&gt;macOS Proxy.</p><p><img src="/images/20210618/20210618002.png"></p><p>此时，在浏览器里访问网页的时候，就可以在 Charles 里看到网络请求了。</p><p>当前绝大多数的软件和网页都是 HTTPS 协议了，如果想抓包 HTTPS 的请求，则需要通过 Charles 的菜单 Proxy–&gt;SSL Proxying Settings 来进行设置。</p><p><img src="/images/20210618/20210618003.png"></p><p>在弹出的对话框中，我们可以进行如下操作：<br>勾选<code> Enable SSL Proxying</code>，并点击 Add 按钮，再编辑如下。</p><p><img src="/images/20210618/20210618004.png"></p><p>Host 填*，Port 填写 443，这样就可以抓取 HTTPS 协议的请求了。</p><h2 id="2-2-App-端"><a href="#2-2-App-端" class="headerlink" title="2.2 App 端"></a>2.2 App 端</h2><p>手机端使用 Charles 需要多几步配置。</p><ul><li>菜单 Proxy–&gt;Proxy Settings </li><li>填入代理端口 8888（也可以自定义填其他端口）；</li><li>勾上Enable transparent HTTP proxying；</li><li>勾选 Support HTTP&#x2F;2。</li></ul><p><img src="/images/20210618/20210618005.png"></p><p>确定手机端代理地址。</p><p>通过点击 Charles 的菜单help–&gt;SSL Proxying–&gt; Install Charles Root Ceriticate On a Mobile Device or Remote Browser：，然后切换到手机端，根据以下图片进行操作，具体步骤为：<br><img src="/images/20210618/20210618006.png"></p><p>在手机端，通过浏览器访问网页：chls.pro&#x2F;ssl，并下载安装证书。</p><p>设置网络代理的值跟上图中一致。</p><p>这样就可以开始抓包了。</p><p><em>注意：</em>有些设备特别是 Android 设备无法直接安装下载的证书，需要进入到设置-&gt;安全-&gt;凭据存储 -&gt;从存储设备安装证书。</p><h1 id="三、接口过滤、拦截和修改"><a href="#三、接口过滤、拦截和修改" class="headerlink" title="三、接口过滤、拦截和修改"></a>三、接口过滤、拦截和修改</h1><p>按以上配置好后，我们就可以在 Charles 面板中看到所有的网络请求。</p><h2 id="3-1-过滤接口请求"><a href="#3-1-过滤接口请求" class="headerlink" title="3.1 过滤接口请求"></a>3.1 过滤接口请求</h2><p>因为所有的网络请求都会被抓取，那么信息太多也会造成干扰，所以可以过滤接口的请求。过滤接口的请求方式有 2 种。</p><h3 id="3-1-1-直接过滤"><a href="#3-1-1-直接过滤" class="headerlink" title="3.1.1 直接过滤"></a>3.1.1 直接过滤</h3><p>直接过滤很简单，直接在 Charles 的 Filter 这栏中填写你要过滤的关键字即可。<br><img src="/images/20210618/20210618007.png"></p><h3 id="3-1-2-通过菜单-Recording-Settings-设置"><a href="#3-1-2-通过菜单-Recording-Settings-设置" class="headerlink" title="3.1.2 通过菜单 Recording Settings 设置"></a>3.1.2 通过菜单 Recording Settings 设置</h3><p>首先，通过 Charles 菜单选择 Proxy–&gt;Recording Settings。</p><p><img src="/images/20210618/20210618008.png"></p><p>然后在弹出的对话框中，选择 Include， 然后点击 Add 按钮，并按照你的需求设置 Filter。</p><p><em>注意：</em>如果你什么都不填写，就表示全部符合条件。</p><p><img src="/images/20210618/20210618009.png"></p><p>通过上述设置，只有网站域名为 baidu.com 的数据才会被抓取，我们根据自己需要更改筛选条件即可。</p><h2 id="3-2-动态修改请求数据"><a href="#3-2-动态修改请求数据" class="headerlink" title="3.2 动态修改请求数据"></a>3.2 动态修改请求数据</h2><p>当想要修改发送给服务端的数据时，最简单的方式就是找到这个请求，然后鼠标右键，并选择 Breakpoints。</p><p><img src="/images/20210618/20210618010.png"></p><p>当再次请求被触发时，它就会被拦截。</p><p><img src="/images/20210618/20210618011.png"></p><p>此时，点击 EditRequest，将会看到这个请求的所有参数，同时你可以直接进行更改后点击 Execute 让它执行</p><p><img src="/images/20210618/20210618012.png"></p><p>点击 Execute 后，请求就会被发送。同时还可以对服务端返回的数据进行修改。</p><p>点击 Edit Response，选择 JSON Text 标签，即可对请求的各项返回进行更改。</p><p><img src="/images/20210618/20210618013.png"></p><p>打断点更改网络请求是 Charles 最常用的一个方法，在实践中，当测试版本升级，模拟接口返回错误时就会用到打断点。</p><p>但是如果接口太多，一个个的打断点的话，这样就很浪费时间了。<br>所以我们可以自定义 BreakPoint Settings。</p><p>方法如下：</p><p>菜单栏选择 Proxy–&gt;BreakPoint Settings。<br><img src="/images/20210618/20210618014.png"></p><p>然后在 Breaking Setting 中，勾选<code>Enable BreakPoints</code>，然后点击 Add 按钮，添加对某个请求的断点设置如下。</p><p><img src="/images/20210618/20210618015.png"></p><p>我们可以根据需求，自己定义要抓取的请求地址；并且可以通过勾选 Request、Reponse 的方式来决定是只更改发往服务端的请求数据（勾选 Request 即可）。</p><h1 id="四、远程映射"><a href="#四、远程映射" class="headerlink" title="四、远程映射"></a>四、远程映射</h1><p>通过 Breakpoint 的方式进行修改请求数据虽然有效，但是修改请求这个操作需要人工干预，需要花费时间。再者，在测试时有可能接口返回，你已经提前知道了，那么就不需要先请求再更改数据，可以准备好返回数据直接进行模拟。</p><p><img src="/images/20210618/20210618016.png"></p><p>方式为点击 Tools –&gt; Map Local，然后在弹出的对话框中，勾选“Enable Map Local”，接着设置我们要覆盖的请求。</p><p><em>注意：</em>Map From 是我们原始请求。Map To 是你期望的结果，这个结果我们可以放在本地文件中，以 Text 或者 Json 的格式保持都可以。当你使用 Map Local 后，当有目标请求发生时，Charles 直接将你提供的文件内容当做返回值返回。</p><p><img src="/images/20210618/20210618017.png"></p><p>远程映射常常用于客户端或者服务端，对返回的时间有超时判断，或者需要更改太多服务端返回值时使用。 毕竟一个个更改接口返回值需要花费时间，而由于超时时间非常短，等你改完再去执行，接口就直接超时了，这个时候就需要用到远程映射来直接更改。</p><h1 id="四、慢网络模拟"><a href="#四、慢网络模拟" class="headerlink" title="四、慢网络模拟"></a>四、慢网络模拟</h1><p>测试时模拟各自不同网络速度的情况也比较常见，Charles 可以轻松做到慢网络模拟。</p><p><img src="/images/20210618/20210618018.png"></p><p>从菜单 Porxy–&gt;Throttle Settings 进入，先通过 Add 添加你要进行网络速度限制的站点，然后勾选<code>Enable Throttling</code>，选择<code>Throttle preset</code>，这个时候会看到不同的网络速度情况，可以根据需要选择，即可完成网络速度限制。</p><p><img src="/images/20210618/20210618019.png"></p><h1 id="五、微服务分支测试"><a href="#五、微服务分支测试" class="headerlink" title="五、微服务分支测试"></a>五、微服务分支测试</h1><p>在采用微服务架构后，我们就需要对不同版本的微服务分支进行测试，那么这就有必要进行分支测试。在当下，分支测试通常都是根据 Header 进行区分。既然如此，我们就可以给指定的请求添加 Header，以 Charles 也可以进行微服务分支测试，方式如下：</p><p><img src="/images/20210618/20210618020.png"></p><p>菜单 Tools -&gt; Rewrite，然后勾选<code>Enable Rewrite</code>、<code>Debug in Error Log</code>，点击 Add，并在右上的 Location 这个栏目下，点击 Add。</p><p><img src="/images/20210618/20210618021.png"></p><p>在弹出的对话框中， Host 输入*，点击 OK。</p><p>输入* 代表任何地址都将被 Rewrite。</p><p><img src="/images/20210618/20210618022.png"></p><p>然后继续点击下图中的 Add 按钮。</p><p><img src="/images/20210618/20210618023.png"></p><p>在下面的图中配置 Rewrite 的规则。</p><p><img src="/images/20210618/20210618024.png"></p><p>其中，Type 的值是个下拉列表， 选择 add Header，where 勾选 Request。</p><p>然后在下方 Replace 栏目，输入想增加的 header 的 key 和 value，保存即可。</p><p><img src="/images/20210618/20210618025.png"></p><p>通过这种方式，可以对微服务的不同分支进行测试。</p><h1 id="六、简单接口并发测试"><a href="#六、简单接口并发测试" class="headerlink" title="六、简单接口并发测试"></a>六、简单接口并发测试</h1><p>Charles 还可以做接口并发。针对某个接口，假设我们想测试其基本的性能，可以直接选择那个接口，然后右键选择 Repeat Advanced。</p><p><img src="/images/20210618/20210618026.png"></p><p>此时，会弹出设置的框让我们选择，其中：</p><ul><li>Iterations：是并发轮次数，进行多少轮次的测试。</li><li>Concurrency：是并发线程数，每轮测试几个请求同时发。</li><li>Repeat delay：可设置轮次之间的间隔，以毫秒计算。</li></ul><p><img src="/images/20210618/20210618027.png"></p><p>点击确定。</p><p><img src="/images/20210618/20210618028.png"></p><p>我们会看到，所有的请求已经发出来了。通过这种方式，压力就产生了，我们可以观察服务端的响应时间来判断起基本的性能是否达标。</p><h1 id="七、Charles-操作常见问题"><a href="#七、Charles-操作常见问题" class="headerlink" title="七、Charles 操作常见问题"></a>七、Charles 操作常见问题</h1><p>Q.:在抓https&#x2F;http2.0协议请求时，Request和Response显示乱码</p><p>A:<br>第一步：点击 【工具栏–&gt;Proxy–&gt;SSL Proxying Settings…】<br><img src="/images/20210618/20210618029.png"><br>第二步：配置请求的域名和端口号，*表示任意<br><img src="/images/20210618/20210618030.png"></p><p>Q：iOS 上证书安装了，但是无法抓包，为什么？</p><p>A：检查</p><ol><li>检查是否信任该证书。 在手机设置-&gt;通用-&gt;关于本机-&gt;证书信任设置中信任。</li><li>通用-&gt;描述文件与设备管理，选中安装的配置文件，并验证。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 抓包 </tag>
            
            <tag> Charles </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iOS图片大小修改和拼接长图</title>
      <link href="/posts/a0e9a4da.html"/>
      <url>/posts/a0e9a4da.html</url>
      
        <content type="html"><![CDATA[<h1 id="一、单张图片尺寸修改"><a href="#一、单张图片尺寸修改" class="headerlink" title="一、单张图片尺寸修改"></a>一、单张图片尺寸修改</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">/// 修改单张图片大小</span><br><span class="line">/// - Parameters:</span><br><span class="line">///   - image: 原始图片</span><br><span class="line">///   - width: 目标宽度</span><br><span class="line">- (UIImage *)fixImageSizeWithImage:(UIImage *)image width:(CGFloat)width &#123;</span><br><span class="line">    CGSize size = image.size;</span><br><span class="line">    if (size.width == width) &#123;</span><br><span class="line">        return image;</span><br><span class="line">    &#125;</span><br><span class="line">    // 计算目标图片高度</span><br><span class="line">    CGFloat height = width * (size.height/size.width);</span><br><span class="line">    // 目标大小</span><br><span class="line">    CGSize newSize = CGSizeMake(width, height);</span><br><span class="line">    UIGraphicsBeginImageContextWithOptions(newSize, NO, [UIScreen mainScreen].scale);</span><br><span class="line">    [image drawInRect:CGRectMake(0, 0, width, height)];</span><br><span class="line">    UIImage *newImage = UIGraphicsGetImageFromCurrentImageContext();</span><br><span class="line">    UIGraphicsEndImageContext();</span><br><span class="line">    return newImage;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="二、多张图片拼接成长图"><a href="#二、多张图片拼接成长图" class="headerlink" title="二、多张图片拼接成长图"></a>二、多张图片拼接成长图</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/// 多张图片拼接成长图</span><br><span class="line">/// - Parameters:</span><br><span class="line">///   - images: 需要拼接的图片</span><br><span class="line">///   - width: 目标图片的宽度</span><br><span class="line">- (UIImage *)stitchImageWithImages:(NSArray&lt;UIImage *&gt; *)images width:(CGFloat)width &#123;</span><br><span class="line">    CGFloat height = 0;</span><br><span class="line">    NSMutableArray *newImages = [NSMutableArray array];</span><br><span class="line">    for (UIImage *image in images) &#123;</span><br><span class="line">        UIImage *newImage = [self fixImageSizeWithImage:image width:width];</span><br><span class="line">        [newImages addObject:newImage];</span><br><span class="line">        height += newImage.size.height;</span><br><span class="line">    &#125;</span><br><span class="line">    CGSize size = CGSizeMake(width, height);</span><br><span class="line">    UIGraphicsBeginImageContextWithOptions(size, NO, [UIScreen mainScreen].scale);</span><br><span class="line">    CGFloat Y = 0;</span><br><span class="line">    for (int i = 0; i &lt; newImages.count; i++) &#123;</span><br><span class="line">        UIImage *image = newImages[i];</span><br><span class="line">        if (i &gt; 0) &#123;</span><br><span class="line">            UIImage *proImage = newImages[i - 1];</span><br><span class="line">            Y = Y + proImage.size.height;</span><br><span class="line">        &#125;</span><br><span class="line">        [image drawInRect:CGRectMake(0,Y, width, image.size.height)];</span><br><span class="line">    &#125;</span><br><span class="line">    UIImage *newImage = UIGraphicsGetImageFromCurrentImageContext();</span><br><span class="line">    UIGraphicsEndImageContext();</span><br><span class="line">    return newImage;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图片尺寸 </tag>
            
            <tag> 拼接 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MacOS使用Homebrew安装MySQL记录</title>
      <link href="/posts/cd80baa0.html"/>
      <url>/posts/cd80baa0.html</url>
      
        <content type="html"><![CDATA[<h1 id="一、环境"><a href="#一、环境" class="headerlink" title="一、环境"></a>一、环境</h1><ul><li>OS: MacOS Sierra 10.12</li><li>Homebrew: 1.1.7</li></ul><h1 id="二、步骤"><a href="#二、步骤" class="headerlink" title="二、步骤"></a>二、步骤</h1><h2 id="2-1-安装-Homebrew"><a href="#2-1-安装-Homebrew" class="headerlink" title="2.1 安装 Homebrew"></a>2.1 安装 Homebrew</h2><p>Homebrew 是 MacOS 上的软件包管理工具</p><p>官方地址：<a href="https://brew.sh/">https://brew.sh</a></p><p>命令行输入:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/bin/bash -c <span class="string">&quot;<span class="subst">$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)</span>&quot;</span></span><br></pre></td></tr></table></figure><h2 id="2-2-使用brew安装MySql"><a href="#2-2-使用brew安装MySql" class="headerlink" title="2.2 使用brew安装MySql"></a>2.2 使用brew安装MySql</h2><h3 id="2-2-1-命令行输入："><a href="#2-2-1-命令行输入：" class="headerlink" title="2.2.1 命令行输入："></a>2.2.1 命令行输入：</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install mysql</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">==&gt; Downloading https://homebrew.bintray.com/bottles/mysql-5.7.17.sierra.bottle.tar.gz</span><br><span class="line">######################################################################## 100.0%</span><br><span class="line">==&gt; Pouring mysql-5.7.17.sierra.bottle.tar.gz</span><br><span class="line">==&gt; Using the sandbox</span><br><span class="line">==&gt; /usr/local/Cellar/mysql/5.7.17/bin/mysqld --initialize-insecure --user=liangze --basedir=/usr/local/Cellar/mysql/5.7.17 --datadir=/usr/local/var/mysql --t</span><br><span class="line">==&gt; Caveats</span><br><span class="line">We&#x27;ve installed your MySQL database without a root password. To secure it run:</span><br><span class="line">    mysql_secure_installation</span><br><span class="line"></span><br><span class="line">To connect run:</span><br><span class="line">    mysql -uroot</span><br><span class="line"></span><br><span class="line">To have launchd start mysql now and restart at login:</span><br><span class="line">  brew services start mysql</span><br><span class="line">Or, if you don&#x27;t want/need a background service you can just run:</span><br><span class="line">  mysql.server start</span><br><span class="line">==&gt; Summary</span><br><span class="line">/usr/local/Cellar/mysql/5.7.17: 14,226 files, 444.4M</span><br></pre></td></tr></table></figure><h3 id="2-2-2-配置MySql"><a href="#2-2-2-配置MySql" class="headerlink" title="2.2.2 配置MySql"></a>2.2.2 配置MySql</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">We’ve installed your MySQL database without a root password. To secure it run:</span><br><span class="line">mysql_secure_installation</span><br></pre></td></tr></table></figure><p>brew 安装完成后，提示运行 <code>mysql_secure_installation</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> &gt; mysql_secure_installation</span><br><span class="line"></span><br><span class="line">Securing the MySQL server deployment.</span><br><span class="line"></span><br><span class="line">Enter password for user root:</span><br><span class="line">Error: Can&#x27;t connect to local MySQL server through socket &#x27;/tmp/mysql.sock&#x27; (2)</span><br></pre></td></tr></table></figure><p>报错了，原因是还未启动 mysql 服务</p><p>启动mysql服务：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql.server start</span><br></pre></td></tr></table></figure><p>再次运行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; mysql_secure_installation</span><br></pre></td></tr></table></figure><p>最后按提示设置sql</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">Securing the MySQL server deployment.</span><br><span class="line"></span><br><span class="line">Connecting to MySQL using a blank password.</span><br><span class="line"></span><br><span class="line">VALIDATE PASSWORD PLUGIN can be used to test passwords</span><br><span class="line">and improve security. It checks the strength of password</span><br><span class="line">and allows the users to set only those passwords which are</span><br><span class="line">secure enough. Would you like to setup VALIDATE PASSWORD plugin?</span><br><span class="line"></span><br><span class="line">Press y|Y for Yes, any other key for No: y</span><br><span class="line"></span><br><span class="line">There are three levels of password validation policy:</span><br><span class="line"></span><br><span class="line">LOW    Length &gt;= 8</span><br><span class="line">MEDIUM Length &gt;= 8, numeric, mixed case, and special characters</span><br><span class="line">STRONG Length &gt;= 8, numeric, mixed case, special characters and dictionary                  file</span><br><span class="line">// 这里提示选一个密码强度等级</span><br><span class="line">Please enter 0 = LOW, 1 = MEDIUM and 2 = STRONG: 1</span><br><span class="line">Please set the password for root here.</span><br><span class="line">// 然后按照所选的密码强度要求设定密码</span><br><span class="line">New password:</span><br><span class="line"></span><br><span class="line">Re-enter new password:</span><br><span class="line"></span><br><span class="line">Estimated strength of the password: 50</span><br><span class="line">Do you wish to continue with the password provided?(Press y|Y for Yes, any other key for No) : y</span><br><span class="line"> ... Failed! Error: Your password does not satisfy the current policy requirements</span><br><span class="line"></span><br><span class="line">New password:</span><br><span class="line"></span><br><span class="line">Re-enter new password:</span><br><span class="line"></span><br><span class="line">Estimated strength of the password: 100</span><br><span class="line">Do you wish to continue with the password provided?(Press y|Y for Yes, any other key for No) : y</span><br><span class="line">By default, a MySQL installation has an anonymous user,</span><br><span class="line">allowing anyone to log into MySQL without having to have</span><br><span class="line">a user account created for them. This is intended only for</span><br><span class="line">testing, and to make the installation go a bit smoother.</span><br><span class="line">You should remove them before moving into a production</span><br><span class="line">environment.</span><br><span class="line">// 这里删除默认无密码用户</span><br><span class="line">Remove anonymous users? (Press y|Y for Yes, any other key for No) : y</span><br><span class="line">Success.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Normally, root should only be allowed to connect from</span><br><span class="line">&#x27;localhost&#x27;. This ensures that someone cannot guess at</span><br><span class="line">the root password from the network.</span><br><span class="line">// 禁止远程root登录，这里按自己需求设置</span><br><span class="line">Disallow root login remotely? (Press y|Y for Yes, any other key for No) : no</span><br><span class="line"></span><br><span class="line"> ... skipping.</span><br><span class="line">By default, MySQL comes with a database named &#x27;test&#x27; that</span><br><span class="line">anyone can access. This is also intended only for testing,</span><br><span class="line">and should be removed before moving into a production</span><br><span class="line">environment.</span><br><span class="line"></span><br><span class="line">// 这里删除默认自带的test数据库</span><br><span class="line">Remove test database and access to it? (Press y|Y for Yes, any other key for No) : y</span><br><span class="line"> - Dropping test database...</span><br><span class="line">Success.</span><br><span class="line"></span><br><span class="line"> - Removing privileges on test database...</span><br><span class="line">Success.</span><br><span class="line"></span><br><span class="line">Reloading the privilege tables will ensure that all changes</span><br><span class="line">made so far will take effect immediately.</span><br><span class="line"></span><br><span class="line">Reload privilege tables now? (Press y|Y for Yes, any other key for No) : y</span><br><span class="line">Success.</span><br><span class="line"></span><br><span class="line">All done!</span><br></pre></td></tr></table></figure><h1 id="三、测试数据库"><a href="#三、测试数据库" class="headerlink" title="三、测试数据库"></a>三、测试数据库</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; mysql -u root -p</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> Homebrew </tag>
            
            <tag> Mac </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iOS 中使用 iconfont 替换 Assets 中的图标资源</title>
      <link href="/posts/43e3f0a1.html"/>
      <url>/posts/43e3f0a1.html</url>
      
        <content type="html"><![CDATA[<h2 id="一、关于-iconfont"><a href="#一、关于-iconfont" class="headerlink" title="一、关于 iconfont"></a>一、关于 iconfont</h2><p>从名字上拆分<code>icon</code> + <code>font</code>字面上大家都可以理解，其实<code>iconfont</code> 就是让我们可以像使用字体一样来使用图标。</p><p>使用 <code>iconfont</code> 的好处有：</p><ul><li>可以减少 <code>App</code> 的体积；</li><li>图标保真缩放，可以省去 <code>@2x</code> 和 <code>@3x</code> 图的适配；</li><li>适应换肤需求，使用方便。<span id="more"></span></li></ul><h2 id="二、使用-iconfont"><a href="#二、使用-iconfont" class="headerlink" title="二、使用 iconfont"></a>二、使用 iconfont</h2><p>首先去 <code>iconfont</code> 图标库下载需求图标</p><p><a href="https://www.iconfont.cn/">阿里巴巴矢量图片库</a></p><p>其它选择</p><p><a href="https://www.easyicon.net/">easyicon</a></p><p><a href="http://fontello.com/">fontello</a></p><p><a href="https://icomoon.io/">icomoon</a></p><p>以阿里巴巴矢量图片库为例使用<code>iconfont</code></p><h3 id="1、选择图片加入购物车加入项目下载"><a href="#1、选择图片加入购物车加入项目下载" class="headerlink" title="1、选择图片加入购物车加入项目下载"></a>1、选择图片加入购物车加入项目下载</h3><p><img src="/images/20190203/Snip20190203_1.png"></p><p>每个图标都会对应一个<code>unicode码</code>和名称。 这些代码是<code>&amp;#xXXXX</code>格式的，但是在 Xcode 中需要转换成<code>\U0000XXXX</code>格式的。</p><h3 id="2、将-iconfont-ttf-移到工程中"><a href="#2、将-iconfont-ttf-移到工程中" class="headerlink" title="2、将 iconfont.ttf 移到工程中"></a>2、将 iconfont.ttf 移到工程中</h3><p><img src="/images/20190203/Snip20190203_2.png"></p><p>下载完以后，我们会发现文件夹里包含如图二文件。我们只需要将<code>iconfont.tff</code>拖入工程中即可。</p><h3 id="3、确保已经导入-iconfont-tff"><a href="#3、确保已经导入-iconfont-tff" class="headerlink" title="3、确保已经导入 iconfont.tff"></a>3、确保已经导入 iconfont.tff</h3><p><img src="/images/20190203/Snip20190203_3.png"></p><p>为了保证<code>iconfont.tff</code>已导入成功，在<code>Target--Build Phases--Bundle Resource</code> 里检查一下。</p><h3 id="4、添加Fonts-provided-by-application字段"><a href="#4、添加Fonts-provided-by-application字段" class="headerlink" title="4、添加Fonts provided by application字段"></a>4、添加<code>Fonts provided by application</code>字段</h3><p><img src="/images/20190203/Snip20190203_4.png"></p><p>打开<code>info.plist</code>文件，添加<code>Fonts provided by application</code>字段。</p><h2 id="三、项目中使用"><a href="#三、项目中使用" class="headerlink" title="三、项目中使用"></a>三、项目中使用</h2><p>简单使用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">label.text = IconfontName(@&quot;mine_logout&quot;); // 这里的“mine_logout”就是图标的名称。</span><br><span class="line">label.font = IconFontSize(64);</span><br><span class="line">label.textColor = [UIColor grayColor];</span><br><span class="line">label.textAlignment = NSTextAlignmentCenter;</span><br><span class="line"></span><br><span class="line">// 如果是设置 button 的图标</span><br><span class="line">[btn setTitle:IconfontName(@&quot;chat_voice_normal&quot;) forState:(UIControlStateNormal)];</span><br><span class="line">[btn setTitle:IconfontName(@&quot;chat_voice_pressed&quot;) forState:(UIControlStateSelected)];</span><br></pre></td></tr></table></figure><p>推荐第三方封装库：</p><p>OC:<br><a href="https://github.com/JohnWong/IconFont">IconFont</a></p><p>Swift:<br><a href="https://github.com/XiangWuShuo/EFIconFont">EFIconFont</a></p><h2 id="四、其它"><a href="#四、其它" class="headerlink" title="四、其它"></a>四、其它</h2><p>推荐两个压缩图标的网站，不会影响画质，也不会变形或模糊。</p><p><a href="https://imagecompressor.com/">Optimizilla</a></p><p><a href="https://img.top/">img.top</a></p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iconfont </tag>
            
            <tag> App 瘦身 </tag>
            
            <tag> 图片压缩 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用Mac自动操作制作@1x@2x@3x图片（切图）</title>
      <link href="/posts/7ea64dc1.html"/>
      <url>/posts/7ea64dc1.html</url>
      
        <content type="html"><![CDATA[<p>在iOS开发中，使用的图片要求导入@1x、@2x和@3x:</p><ul><li><p>使用@1x格式：iPhone3GS（基本上是淘汰了）</p></li><li><p>使用@2x格式：iPhone 4，4S，5，5S，5C，SE，6，6S，7，8，XR</p></li><li><p>使用@3x格式：iPhone 6Plus、6sPlus、7Plus、8Plus、X、XS、XS Max</p></li></ul><p>这样在开发过程中，将三种图片（比如分别为<code>【xxx.png】</code>、<code>【xxx@2x.png】</code> 和 <code>【xxx@3x.png】</code>）导入到工程图库中的时候可以自动被识别为1x、2x和3x大小的图片</p><span id="more"></span><p>可以利用Mac系统中自带的服务自己制作一个快速生成@1x、@2x和@3x图片的功能</p><p>首先<code>spotlight</code>搜索<code>Automator</code>，然后按<code>Enter</code>打开</p><p><img src="/images/20190120/Snip20190718_2.png" alt="Snip20190718_2.png"></p><p>新建文稿</p><p><img src="/images/20190120/Snip20190718_3.png" alt="Snip20190718_3.png"></p><p>选取文稿类型为<code>快速操作</code></p><p><img src="/images/20190120/Snip20190718_4.png" alt="Snip20190718_4.png"></p><p>在<code>工作流程收到当前</code>的后面选择<code>图像文件</code></p><p><img src="/images/20190120/Snip20190718_5.png" alt="Snip20190718_5.png"></p><p>在左边窗口的“<code>操作</code>”下，选择“<code>资源库</code>”中的“<code>文件和文件夹</code>”，将右侧中的“<code>给访达项目重新命名</code>”拖入最右侧的窗口中，（如果警告提示是否要增加一个“<code>拷贝访达项目</code>”操作，选择“<code>不添加</code>”），选择“<code>添加文本</code>”，在输入框中输入【<code>@3x</code>】</p><p><img src="/images/20190120/Snip20190718_6.png" alt="Snip20190718_6.png"></p><p>拖入“<code>复制访达项目</code>”</p><p><img src="/images/20190120/Snip20190718_7.png" alt="Snip20190718_7.png"></p><p>选择左侧“<code>资源库</code>”中的照片，将“<code>缩放图像</code>”拖入右侧窗口（如果警告提示是否要增加一个“<code>拷贝访达项目</code>”操作，选择“<code>不添加</code>”），并选择“<code>按百分比</code>”，输入【<code>66</code>】</p><p><img src="/images/20190120/Snip20190718_8.png" alt="Snip20190718_8.png"></p><p>再拖入“<code>文件和文件夹</code>”下的“<code>给访达项目重新命名</code>”，（如果警告提示是否要增加一个“<code>拷贝访达项目</code>”操作，选择“<code>不添加</code>”）并选择【<code>替换文本</code>】，查找【<code>“</code>】，以【<code>仅基本名称</code>】；再拖入“<code>文件和文件夹</code>”下的“<code>给访达项目重新命名</code>”，并选择【<code>替换文本</code>】，查找【<code>@3x”的副本</code>】，以【<code>仅基本名称</code>】，替换成【<code>@2x</code>】</p><p><img src="/images/20190120/Snip20190718_9.png" alt="Snip20190718_9.png"></p><p>拖入“<code>复制访达项目</code>”，选择左侧“<code>资源库</code>”中的照片，将“<code>缩放图像</code>”拖入右侧窗口（如果警告提示是否要增加一个“<code>拷贝访达项目</code>”操作，选择“<code>不添加</code>”），并选择“<code>按百分比</code>”，输入【<code>50</code>】</p><p><img src="/images/20190120/Snip20190718_10.png" alt="Snip20190718_10.png"></p><p>再拖入“<code>文件和文件夹</code>”下的“<code>给访达项目重新命名</code>”，（如果警告提示是否要增加一个“<code>拷贝访达项目</code>”操作，选择“<code>不添加</code>”）并选择【<code>替换文本</code>】，查找【<code>“</code>】，以【<code>仅基本名称</code>】，再拖入“<code>文件和文件夹</code>”下的“<code>给访达项目重新命名</code>”，并选择【<code>替换文本</code>】，查找【<code>@2x”的副本</code>】，以【<code>仅基本名称</code>】</p><p><img src="/images/20190120/Snip20190718_11.png" alt="Snip20190718_11.png"></p><p>然后保存，将“<code>快速操作</code>”存储为“<code>制作@2x@3x图片</code>”</p><p><img src="/images/20190120/Snip20190718_12.png" alt="Snip20190718_12.png"></p><p>每次使用的时候，只需选中图片，选择<code>访达 -&gt; 服务 -&gt; 制作@2x@3x图片</code>，就会自动生成三个图片：<code>【xxx.png】</code>、<code>【xxx@2x.png】</code>和<code>【xxx@3x.png】</code></p><p><img src="/images/20190120/Snip20190718_13.png" alt="Snip20190718_13.png"></p><p>或者选择图片，右键<code>服务 -&gt; 制作@2x@3x图片</code>一样会自动生成三个图片：<code>【xxx.png】</code>、<code>【xxx@2x.png】</code> 和 <code>【xxx@3x.png】</code></p><p><img src="/images/20190120/Snip20190718_14.png" alt="Snip20190718_14.png"></p><p>注意：这里3x的图片是当前图片，也就制作的原图就是3x的；</p><p>最终效果~</p><p><img src="/images/20190120/Snip20190718_15.png" alt="Snip20190718_15.png"></p><h2 id="因为mac系统更新，命名有些变化"><a href="#因为mac系统更新，命名有些变化" class="headerlink" title="因为mac系统更新，命名有些变化"></a>因为mac系统更新，命名有些变化</h2><p>最新操作流程图<br><img src="/images/20190120/Snipaste_2024-03-06_18-25-22.png" alt="制作@2x@3x图片"></p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS开发 </tag>
            
            <tag> UI </tag>
            
            <tag> 切图 </tag>
            
            <tag> 自动操作 </tag>
            
            <tag> Automator </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TabBar 的 Item 按钮的像素大小</title>
      <link href="/posts/5d5dacf3.html"/>
      <url>/posts/5d5dacf3.html</url>
      
        <content type="html"><![CDATA[<h2 id="TabBar的Item按钮的像素大小要求"><a href="#TabBar的Item按钮的像素大小要求" class="headerlink" title="TabBar的Item按钮的像素大小要求"></a>TabBar的Item按钮的像素大小要求</h2><p>根据<a href="https://developer.apple.com/design/human-interface-guidelines/">苹果官方人机界面指南（Human Interface Guidelines）</a>可以得知：</p><p>iOS系统会根据设备和方向显示两种标签栏：<code>常规（Regular）</code>和<code>紧凑（Compact）</code>，<br>所以在设置<code>自定义TabBar Item</code>的时候也应该包含常规和紧凑两种不同的尺寸～</p><p><code>根据图形是圆形、方形、宽形、高形</code>，像素也有不同的要求：</p><ul><li><p>如果图标是圆形的，应该提供：25pt@2x、25pt@3x、18pt@2x、18pt@3x</p></li><li><p>如果图标是方形的，应该提供：23pt@2x、23pt@3x、17pt@2x、17pt@3x</p></li></ul><span id="more"></span><ul><li><p>如果图标是宽形的，应该提供：31pt@2x、31pt@3x、23pt@2x、23pt@3x</p></li><li><p>如果图标是高形的，应该提供：28pt@2x、28pt@3x、20pt@2x、20pt@3x</p></li></ul><h2 id="完整表格"><a href="#完整表格" class="headerlink" title="完整表格~"></a>完整表格~</h2><p><img src="/images/20190120/Snip20190120_1.png" alt="Snip20190120_1.png"></p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS开发 </tag>
            
            <tag> UI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>复杂度分析</title>
      <link href="/posts/a1a87ec3.html"/>
      <url>/posts/a1a87ec3.html</url>
      
        <content type="html"><![CDATA[<h2 id="一、概念"><a href="#一、概念" class="headerlink" title="一、概念"></a>一、概念</h2><p><code>算法复杂度</code>是指算法在编写成可执行程序后，运行时所需要的资源，资源包括时间资源和内存资源。应用于数学和计算机导论。</p><p>同一问题可用不同算法解决，而一个算法的质量优劣将影响到算法乃至程序的效率。算法分析的目的在于选择合适算法和改进算法。一个算法的评价主要从<code>时间复杂度</code>和<code>空间复杂度</code>来考虑。</p><p>学习数据结构和算法，就一定离不开时间、空间复杂度分析。复杂度分析是整个算法学习的精髓，只要掌握了它，数据结构和算法的内容基本上就掌握了一半。</p><span id="more"></span><h2 id="二、为什么需要复杂度分析"><a href="#二、为什么需要复杂度分析" class="headerlink" title="二、为什么需要复杂度分析"></a>二、为什么需要复杂度分析</h2><ol><li>预测算法所需要的资源<ul><li>计算时间（CPU消耗）</li><li>内存空间（RAM消耗）</li><li>通信时间（带宽消耗）</li></ul></li><li>预测算法的运行时间<ul><li>在给定输入规模时，所执行的基本操作数量</li><li>或者称之为算法复杂度（Algorithm Complexity）</li></ul></li><li>测试结果非常依赖测试环境<ul><li>测试环境中硬件的不同对测试结果有很大的影响</li></ul></li><li>测试结果受到数据规模的影响很大<ul><li>对于小规模的数据排序，插入排序可能反倒会比快速排序要快</li></ul></li></ol><p>所以，我们需要一个不用具体的测试数据来测试，就可以粗略地估计算法的执行效率的方法。这就是时间、空间复杂度分析方法。</p><h2 id="三、大-O-复杂度表示法"><a href="#三、大-O-复杂度表示法" class="headerlink" title="三、大 O 复杂度表示法"></a>三、大 O 复杂度表示法</h2><p>大O表示法就是将算法的所有步骤转换为代数项，然后排除不会对问题的整体复杂度产生较大影响的较低阶常数和系数。</p><p>一起来估算下面的代码执行时间，求1，2，3…n的累加和：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int cal(int n) &#123;</span><br><span class="line">    int sum = 0;</span><br><span class="line">    int i = 0;</span><br><span class="line">    for (; i &lt;= n; ++i) &#123;</span><br><span class="line">        sum = sum + i;</span><br><span class="line">    &#125;</span><br><span class="line">    return sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从<code>CPU</code>的角度来看，这段代码的每一行都执行着类似的操作：<code>读数据-运算-写数据 </code>。尽管每行代码对应的<code>CPU</code>执行的个数、执行的时间都不一样，但是，这里只是粗略的估计，所以可以假设每行代码执行的时间都一样，为 <code>unit_time</code>。在这个假设基础之上，这段代码的总执行时间是多少呢？<br>第 2、3 行代码分别需要1个<code>unit_time</code>的执行时间，第 4、5 行都运行了<code>n</code>遍，所以需要<code>2n * unit_time</code>的执行时间，所以这段代码总的执行时间就是<code>(2n + 2) * unit_time</code>。可以看出来，所有代码的执行时间<code>T(n)</code>与每行代码的执行次数成正比。</p><p>按照这个分析思路，再来看下面这段代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">int cal(int n) &#123;</span><br><span class="line">    int sum = 0;</span><br><span class="line">    int i = 1;</span><br><span class="line">    int j = 1;</span><br><span class="line">    for (; i &lt;= n; ++i) &#123;</span><br><span class="line">        j = 1;</span><br><span class="line">        for (; j &lt;= n; ++j) &#123;</span><br><span class="line">            sum = sum + j * j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>依旧假设每个语句的执行时间是<code>unit_time</code>。那这段代码的总执行时间<code>T(n)</code>是多少呢？<br>第 2、3、4 行代码，每行都需要 1 个 <code>unit_time</code> 执行时间，第 5、6 行代码循环执行了 <code>n</code> 遍，需要 <code>2n * unit_time</code> 的执行时间，第 7、8 行代码循环执行了 n<sup>2</sup> 遍，所以需要 2n<sup>2</sup> * unit_time 的执行时间。所以，整段代码总的执行时间 T(n) &#x3D; (2n<sup>2</sup> + 2n + 3) * unit_time。</p><p>尽管不知道 <code>unit_time</code> 的具体值，但是通过上面两段代码的执行时间的推导过程，可以得到一个非常重要的规律，那就是：所有代码的执行时间 <code>T(n)</code> 与每行代码的执行次数 <code>n</code> 成正比。</p><p>这个规律总结成公式就是：</p><p> <img src="/images/20180930/%E5%A4%A7O%E5%A4%8D%E6%9D%82%E5%BA%A6%E8%A1%A8%E7%A4%BA%E6%B3%95.png" alt="大O复杂度表示法"></p><ul><li><code>T(n)</code> 表示代码执行的时间；</li><li><code>n</code> 表示数据规模的大小；</li><li><code>f(n)</code> 表示每行代码执行的次数总和（因为是一个公式，所以用<code>f(n)</code>来表示）；</li><li><code>O</code> 表示代码的执行时间 <code>T(n)</code> 与 <code>f(n)</code> 表达式成正比；</li></ul><p>所以，第一个例子中的 T(n) &#x3D; O(2n + 2)，第二个例子中的 T(n) &#x3D; O(2n<sup>2</sup> + 2n + 3)。 这就是<code>大 O 时间复杂度表示法</code>。大 <code>O</code> 时间复杂度实际上并不具体表示<code>代码真正的执行时间，而是表示代码执行时间随着数据规模增长的变化趋势</code>，所以，也叫作<code>渐进时间复杂度（asymptotic time complexity）</code>，简称<code>时间复杂度</code>。</p><p>当 n 很大时，比如10000、100000。而公式中的低阶、常量、系数三部分并不左右增长趋势，所以都可以忽略。只需要记录一个最大量级就可以了，如果用大 O 表示法表示刚才的两段代码的时间复杂度，就可以记为: T(n) &#x3D; O(n)；T(n) &#x3D; O(n<sup>2</sup>)。</p><h2 id="四、时间复杂度分析"><a href="#四、时间复杂度分析" class="headerlink" title="四、时间复杂度分析"></a>四、时间复杂度分析</h2><h3 id="1-只关注循环执行次数最多的一段代码"><a href="#1-只关注循环执行次数最多的一段代码" class="headerlink" title="1.只关注循环执行次数最多的一段代码"></a>1.只关注循环执行次数最多的一段代码</h3><p>刚才说了， 大 O 这种复杂度表示法只是表示一种变化趋势。通常会忽略掉公司中的常量、低价、系数，只需要记录一个最大阶量级就可以了，所有在分析一个算法、一段代码的时间复杂度的时候，也只关注循环执行次数最多的那一段代码就可以了。这段核心代码执行次数的 n 的量级，就是整段要分析代码的时间复杂度。</p><h3 id="2-加法法则：总复杂度等于量级最大的那段代码的复杂度"><a href="#2-加法法则：总复杂度等于量级最大的那段代码的复杂度" class="headerlink" title="2. 加法法则：总复杂度等于量级最大的那段代码的复杂度"></a>2. 加法法则：总复杂度等于量级最大的那段代码的复杂度</h3><p>如果T1(n) &#x3D; O(f(n))，T2(n) &#x3D; O(g(n))；那么T(n) &#x3D; T1(n) + T2(n) &#x3D; max(O(f(n)), O(g(n))) &#x3D; O(max(f(n), g(n)))。</p><h3 id="3-乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积"><a href="#3-乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积" class="headerlink" title="3.乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积"></a>3.乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积</h3><p>如果 T1(n) &#x3D; O(f(n))，T2(n) &#x3D; O(g(n))；那么 T(n) &#x3D; T1(n)*T2(n) &#x3D; O(f(n))*O(g(n)) &#x3D; O(f(n)*g(n))。<br>也就是说，假设 T1(n) &#x3D; O(n), T2(n) &#x3D; O(n<sup>2</sup>)，则T1(n) * T2(n) &#x3D; O(n<sup>3</sup>)。</p><h2 id="五、几种常见时间复杂度实例分析"><a href="#五、几种常见时间复杂度实例分析" class="headerlink" title="五、几种常见时间复杂度实例分析"></a>五、几种常见时间复杂度实例分析</h2><p>虽然代码千差万别，但是常见的复杂度量级并不多。</p><p><img src="/images/20180930/%E5%A4%8D%E6%9D%82%E5%BA%A6%E9%87%8F%E7%BA%A7.jpg" alt="复杂度量级"></p><p>上面罗列的复杂度量级，可以粗略的分为两类，<code>多项式量级</code>和<code>非多项式量级</code>。其中非多项式量级只有两个：O(2<sup>n</sup>) 和 O(n!)。</p><p>当数据规模 n 越来越大时，非多项式量级算法的执行时间会急剧增加，求解问题的执行时间会无限增长。所以非多项式时间复杂度的算法其实是非常低效的算法。</p><h3 id="1-O-1"><a href="#1-O-1" class="headerlink" title="1. O(1)"></a>1. O(1)</h3><p>O(1) 只是常量级时间复杂度的一种表示方法，并不是指只执行了一行代码。即只要代码的执行时间不随着 n 的增大而增长，这样代码的时间复杂度都记作O(1)。或者说，<code>一般情况下，只要算法中不存在循环语句、递归语句，即使有成千上万行的代码，其时间复杂度也是O(1)</code>。</p><p>比如：下面代码即便有三行，它的时间复杂度也是O(1)，而不是O(3)。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int i = 1;</span><br><span class="line">int j = 3;</span><br><span class="line">int sum = i + j;</span><br></pre></td></tr></table></figure><h3 id="2-O-logn-、O-nlogn"><a href="#2-O-logn-、O-nlogn" class="headerlink" title="2. O(logn)、O(nlogn)"></a>2. O(logn)、O(nlogn)</h3><p>对数阶时间复杂度非常常见，同时也是最难分析的一种时间复杂度。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">i = 1;</span><br><span class="line">while (i &lt;= n) &#123;</span><br><span class="line">    i = i * 2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从代码中可以知道，变量 i 的取值就是一个等比数列。</p><p><img src="/images/20180930/%E7%AD%89%E6%AF%94%E6%95%B0%E5%88%97.jpg" alt="等比数列"></p><p>通过 2<sup>x</sup> &#x3D; n 求解 x 的公式 x &#x3D; log<sub>2</sub>n，所以这段代码的时间复杂度就是O(log<sub>2</sub>n)。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">i = 1;</span><br><span class="line">while (i &lt;= n) &#123;</span><br><span class="line">    i = i * 3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据刚才的思路，可以看出这段代码的时间复杂度为O(log<sub>3</sub>n)<br>实际上不管是以 2 为底、以 3 为底还是以 10 为底，都可以把对数阶的时间复杂度记为 O(logn)。<br>我们知道，对数之间是可以相互转换的，log<sub>3</sub>n 就等于 log<sub>3</sub>2 * log<sub>3</sub>n， 所以O(log<sub>3</sub>n) &#x3D; O(C * log<sub>2</sub>n)，其中 C * log<sub>3</sub>2 是一个常量。基于<code>在采用大 O 标记复杂度的时候可以忽略系数，即 O(Cf(n)) = O(f(n))</code>。所以，O(log<sub>2</sub>n) 就等于 O(log<sub>3</sub>n)。因此，在对数阶时间复杂度的表示方法里，忽略对数的“底”，统一表示为 O(logn)。<br>O(nlogn)，如果一段代码的时间复杂度是 O(logn)，循环执行 n 遍，时间复杂度就变成 O(nlogn)了，而且 O(nlogn) 也是一种非常常见的算法时间复杂度。比如，归并排序、快速排序的时间复杂度都是 O(nlogn)。</p><h3 id="3-O-m-n-、O-m-n"><a href="#3-O-m-n-、O-m-n" class="headerlink" title="3. O(m+n)、O(m*n)"></a>3. O(m+n)、O(m*n)</h3><p>再来看一种和前面不一样的时间复杂度，代码的复杂度由两个数据的规模来决定。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">int cal(int m, int n) &#123;</span><br><span class="line">    int sum_1 = 0;</span><br><span class="line">    int i = 1;</span><br><span class="line">    for (; i &lt; m; ++i) &#123;</span><br><span class="line">        sum_1 = sum_1 + i;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    int sum_2 = 0;</span><br><span class="line">    int j = 1;</span><br><span class="line">    for (; j &lt; n; ++i) &#123;</span><br><span class="line">        sum_2 = sum_2 + j;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return sum_1 + sum_2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面代码中可以看出， m 和 n 是表示两个数据的规模。无法事先评估 m 和 n 谁的量级大，所以在表示时间复杂度的时候，就不能简单地利用加法法则，省略掉其中一个。所以，上面代码的时间复杂度就是O(m+n)。</p><p>针对这种情况，原来的加法法则就不正确了，我们需要将加法法则改为:T1(m) + T2(n) &#x3D; O(f(m) + g(n))。但是乘法法则继续有效：T1(m) * T2(n) &#x3D; O(f(m) * g(n))。</p><h2 id="六、空间复杂度分析"><a href="#六、空间复杂度分析" class="headerlink" title="六、空间复杂度分析"></a>六、空间复杂度分析</h2><p><code>空间复杂度(Space Complexity)</code>是对一个算法在运行过程中临时占用存储空间大小的量度，记做<code>S(n)=O(f(n))</code>。比如直接插入排序的时间复杂度是<code>O(n^2)</code>,空间复杂度是<code>O(1)</code> 。而一般的递归算法就要有<code>O(n)</code>的空间复杂度了，因为每次递归都要存储返回信息。一个算法的优劣主要从算法的执行时间和所需要占用的存储空间两个方面衡量。</p><p>时间复杂度的全称是<strong>渐进时间复杂度，表示算法的执行时间与数据规模之间的增长关系</strong>。类比一下，空间复杂度全称就是<strong>渐进空间复杂度（asymptotic space complexity），表示算法的存储空间与数据规模之间的增长关系</strong>。</p><p>空间复杂度分析相比时间复杂度分析简单的多，而且常见的空间复杂度就是O(1)、O(n)、O(n<sup>2</sup>)，像 O(logn)、O(nlogn) 这样的对数阶复杂度平时都用不到。</p><h2 id="七、总结"><a href="#七、总结" class="headerlink" title="七、总结"></a>七、总结</h2><p>复杂度也叫渐进复杂度，包括时间复杂度和空间复杂度，用来分析算法执行效率与数据规模之间的增长关系，可以粗略地表示，越高阶复杂度的算法，执行效率越低。<br>常见的复杂度并不多，从低阶到高阶有：O(1)、O(logn)、O(n)、O(nlogn)、O(n<sup>2</sup>)。</p><p><img src="/images/20180930/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E7%BA%BF%E6%80%A7%E5%9B%BE.jpg" alt="时间复杂度线性图"></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构和算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 时间复杂度、空间复杂度 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法和数据结构</title>
      <link href="/posts/f8580263.html"/>
      <url>/posts/f8580263.html</url>
      
        <content type="html"><![CDATA[<p>数据结构这门课程是大小计算机系的必修课，很多人第一次接触这门课时，都会觉的数据结构和算法很抽象，晦涩难懂，宛如天书。虽然在大学的时候老师讲的都听明白了，但是毕业后不是专门从事算法相关的工作。所以到现在已经忘记很多了。如果你想让自己的编程能力有质的飞跃，不再停留于调用现成的东西而是追求更完美的实现， 对编程还有追求？不想被行业淘汰？那就不要只会写凑合能用的代码！那么数据结构和算法是你的必修课！</p><span id="more"></span><h2 id="一、什么是数据结构"><a href="#一、什么是数据结构" class="headerlink" title="一、什么是数据结构"></a>一、什么是数据结构</h2><p>官方定义:<br>数据结构是一门研究非数值计算的程序设计问题中的操作对象，以及它们之间的关系和操作等相关问题的学科。</p><p>大部分数据结构和算法的教材，都会给这两个概念明确一下定义， 但是这些定义都很抽象，对理解这两个概念并没有实质性的帮助，反倒会让你陷入死抠定义的误区。<br>虽然我们说没必要深挖严格的定义，但是这并不等于不需要理解概念。</p><h3 id="广义上讲"><a href="#广义上讲" class="headerlink" title="广义上讲"></a>广义上讲</h3><p>数据结构就是指一组数据的存储结构。算法就是操作数据的一组方法。</p><h3 id="狭义上讲"><a href="#狭义上讲" class="headerlink" title="狭义上讲"></a>狭义上讲</h3><p>是指某些著名的数据结构和算法，比如队列、栈、二分查找、动态规划等。</p><h2 id="二、数据结构和算法的关系"><a href="#二、数据结构和算法的关系" class="headerlink" title="二、数据结构和算法的关系"></a>二、数据结构和算法的关系</h2><p>大部分的书和教程都会把数据结构和算法这两个东西放到一起讲，这是因为数据结构和算法是相辅相成的。<br>数据机构是为算法服务的，算法要作用在特定的数据结构之上。</p><p>比如，常用的二分查找算法需要用数组来存储数据，因为数组具有随机访问的特点。但是如果选用链表这种数据结构，二分查找算法就无法工作了，因为链表并不支持随机访问。</p><p>数据结构是静态的，它只是组织数据的一种方式。如果不在它的基础上操作、构建算法，孤立的数据结构就是没有用的。</p><h2 id="数据结构和算法涵盖的内容"><a href="#数据结构和算法涵盖的内容" class="headerlink" title="数据结构和算法涵盖的内容"></a>数据结构和算法涵盖的内容</h2><p><img src="/images/20180930/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95.jpg" alt="数据结构和算法"></p><p>20个最常用的、最基础的数据结构和算法：<br>10个数据结构：数组、链表、栈、队列、散列表、二叉树、堆、跳表、图、Trie 树；<br>10个算法：递归、排序、二分查找、搜索、哈希算法、贪心算法、分治算法、回溯算法、动态规划、字符串匹配算法。</p><p>不管是应付面试还是工作需要，只要集中精力逐一攻克这 20 个知识点就足够了。而且掌握了这些基础的数据结构和算法，再去学更加复杂的数据结构和算法，就会非常容易、非常快。</p><p>学习数据结构和算法的过程，是非常好的思维训练的过程，所以，千万不要被动的记忆，要多辩证地思考，多问为什么。如果你一直这么坚持做，你会发现，等你学完之后，写代码的时候就会不由自主地考虑到很多性能方面的事情，时间复杂度、空间复杂度非常高的垃圾代码出现的次数就会越来越少。你的汇编内功就真正得到了修炼。</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构和算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 数据结构和算法 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LLVM-Clang插件开发</title>
      <link href="/posts/5dd1b1a1.html"/>
      <url>/posts/5dd1b1a1.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>前面一篇博客介绍了<code>LLVM</code>相关内容，那现在就开始用学到的<code>LLVM</code>知识，做一下实践；</p><p>–<code>Clang</code>插件开发</p><span id="more"></span><h2 id="一、插件目录"><a href="#一、插件目录" class="headerlink" title="一、插件目录"></a>一、插件目录</h2><ul><li>在【<code>clang/tools</code>】源码目录下新建一个插件目录，叫做【<code>ly-plugin</code>】(自定义)</li></ul><p> <img src="/images/20180913/Snip20180913_1.png"></p><ul><li>在【<code> clang/tools/CMakeLists.txt</code>】最后加入内容： <code>add_clang_subdirectory(ly -plugin)</code>，小括号里是插件目录名</li></ul><p> <img src="/images/20180913/Snip20180913_2.png"></p><h2 id="二、插件必要的文件"><a href="#二、插件必要的文件" class="headerlink" title="二、插件必要的文件"></a>二、插件必要的文件</h2><ul><li>在【<code>ly-plugin</code>】目录下新建一个【<code>CMakeLists.txt</code>】，文件内容是：<code>add_llvm_loadable_module(LYPlugin LYPlugin.cpp</code>)</li></ul><p> <img src="/images/20180913/Snip20180913_3.png"></p><p> <img src="/images/20180913/Snip20180913_4.png"></p><h2 id="三、编写插件源码"><a href="#三、编写插件源码" class="headerlink" title="三、编写插件源码"></a>三、编写插件源码</h2><ul><li>【<code>LYPlugin.cpp</code>】参考</li></ul><p> <img src="/images/20180913/Snip20180913_5.png"></p><h2 id="四、编译插件"><a href="#四、编译插件" class="headerlink" title="四、编译插件"></a>四、编译插件</h2><ul><li>利用<code>cmake</code>生成的<code>Xcode</code>项目来编译插件（第一次编写完插件，需要利用<code>cmake</code>重新生成一下<code>Xcode</code>项目）</li><li>插件源代码在【<code>Sources/Loadable modules</code>】目录下可以找到，这样就可以直接在<code>Xcode</code>里编写插件代码</li><li>选择<code>LYPlugin</code>这个<code>target</code>进行编译，编译完会生成一个动态库文件</li></ul><p> <img src="/images/20180913/Snip20180913_6.png"></p><p> <img src="/images/20180913/Snip20180913_7.png"></p><p> <img src="/images/20180913/Snip20180913_8.png"></p><h2 id="五、加载插件"><a href="#五、加载插件" class="headerlink" title="五、加载插件"></a>五、加载插件</h2><ul><li>在<code>Xcode</code>项目中指定加载插件动态库：<code>Build Settings &gt; OTHER_CFLAGS</code></li><li><code>-Xclang -load -Xclang</code> 动态库路径 <code>-Xclang -add-plugin -Xclang</code> 插件名称</li></ul><p> <img src="/images/20180913/Snip20180913_9.png"></p><h2 id="六、Hack-Xcode"><a href="#六、Hack-Xcode" class="headerlink" title="六、Hack Xcode"></a>六、Hack Xcode</h2><ul><li>首先要对<code>Xcode</code>进行<code>Hack</code>，才能修改默认的编译器</li><li>下载【<a href="https://pan.baidu.com/s/12mG4Ozp8L-Ry4IIPMf1ZJg">XcodeHacking.zip</a>】，解压，修改【<code>HackedClang.xcplugin/Contents/Resources/HackedClang.xcspec</code>】的内容，设置一下自己编译好的<code>clang</code>的路径</li></ul><p> <img src="/images/20180913/Snip20180913_10.png"></p><ul><li>然后在<code>XcodeHacking</code>目录下进行命令行，将<code>XcodeHacking</code>的内容剪切到<code>Xcode</code>内部</li></ul> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo mv HackedClang.xcplugin `xcode-select-printpath`/../PlugIns/Xcode3Core.ideplugin/Contents/SharedSupport/Developer/Library/Xcode/Plug-ins</span><br></pre></td></tr></table></figure> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo mv HackedBuildSystem.xcspec `xcode-select-printpath`/Platforms/iPhoneSimulator.platform/Developer/Library/Xcode/Specifications</span><br></pre></td></tr></table></figure><h2 id="七、修改Xcode的编译器"><a href="#七、修改Xcode的编译器" class="headerlink" title="七、修改Xcode的编译器"></a>七、修改Xcode的编译器</h2><p><img src="/images/20180913/Snip20180913_11.png"></p><h2 id="八、编译项目"><a href="#八、编译项目" class="headerlink" title="八、编译项目"></a>八、编译项目</h2><ul><li>编译项目后，会在编译日志看到<code>LYPlugin</code>插件的打印信息（如果插件更新了，最好先<code>Clean</code>一下项目）</li></ul><p> <img src="/images/20180913/Snip20180913_12.png"></p><h2 id="九、更多"><a href="#九、更多" class="headerlink" title="九、更多"></a>九、更多</h2><ul><li><p>想要实现更复杂的插件功能，就需要利用<code>clang</code>的<code>API</code>针对语法树（<code>AST</code>）进行相应的分析和处理</p></li><li><p>关于AST的资料</p><ul><li><a href="https://clang.llvm.org/doxygen/namespaceclang.html">https://clang.llvm.org/doxygen/namespaceclang.html</a></li><li><a href="https://clang.llvm.org/doxygen/classclang_1_1Decl.html">https://clang.llvm.org/doxygen/classclang_1_1Decl.html</a></li><li><a href="https://clang.llvm.org/doxygen/classclang_1_1Stmt.html">https://clang.llvm.org/doxygen/classclang_1_1Stmt.html</a></li></ul></li></ul><h2 id="十、推荐书籍"><a href="#十、推荐书籍" class="headerlink" title="十、推荐书籍"></a>十、推荐书籍</h2><p><img src="/images/20180913/Snip20180913_13.png"></p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LLVM </tag>
            
            <tag> Clang </tag>
            
            <tag> 插件开发 </tag>
            
            <tag> 编译器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LLVM</title>
      <link href="/posts/6d8a8bc2.html"/>
      <url>/posts/6d8a8bc2.html</url>
      
        <content type="html"><![CDATA[<h2 id="一、什么是LLVM？"><a href="#一、什么是LLVM？" class="headerlink" title="一、什么是LLVM？"></a>一、什么是LLVM？</h2><p><img src="/images/20180912/Snip20180912_1.png"></p><ul><li>官网：<a href="https://llvm.org/">https://llvm.org/</a></li><li>The <code>LLVM</code> Project is a collection of modular and reusable <code>compiler</code> and <code>toolchain</code> technologies.<br>（<code>LLVM</code>项目是模块化、可重用的<code>编译器</code>以及工具<code>链技术</code>的集合。）</li><li>美国计算机协会 (ACM) 将其<code>2012</code>年软件系统奖项颁给了<code>LLVM</code>，之前曾经获得此奖项的软件和技术包括：<code>Java</code>、<code>Apache</code>、 <code>Mosaic</code>、<code>the World Wide Web</code>、<code>Smalltalk</code>、<code>UNIX</code>、<code>Eclipse</code>等等<span id="more"></span></li><li>创始人<code>Chris Lattner</code>，亦是<code>Swift</code>之父;</li><li>有些文章把<code>LLVM</code>当做<code>Low Level Virtual Machine</code>（低级虚拟机）的缩写简称，官方描述如下:<code>The name &quot;LLVM&quot; itself is not an acronym; it is the full name of the project.</code>(<code>LLVM</code>这个名称本身不是首字母缩略词; 它是项目的全名)</li></ul><h2 id="二、传统的编译器架构和LLVM架构"><a href="#二、传统的编译器架构和LLVM架构" class="headerlink" title="二、传统的编译器架构和LLVM架构"></a>二、传统的编译器架构和LLVM架构</h2><p><img src="/images/20180912/Snip20180912_2.png"><br><img src="/images/20180912/Snip20180912_3.png"></p><ul><li>不同的前端后端使用统一的中间代码<code>LLVM Intermediate Representation </code>(<code>LLVM IR</code>) </li><li>如果需要支持一种新的编程语言，那么只需要实现一个新的前端</li><li>如果需要支持一种新的硬件设备，那么只需要实现一个新的后端 </li><li>优化阶段是一个通用的阶段，它针对的是统一的<code>LLVM IR</code>，不论是支持新的编程语言，还是支持新的硬件设备，都不需要对优化阶段做修改</li><li>相比之下，<code>GCC</code>的前端和后端没分得太开，前端后端耦合在了一起。所以<code>GCC</code>为了支持一门新的语言，或者为了支持一个新的目标平台，就变得特别困难 </li><li><code>LLVM</code>现在被作为实现各种静态和运行时编译语言的通用基础结构（<code>GCC</code>家族、<code>Java</code>、<code>.NET</code>、<code>Python</code>、<code>Ruby</code>、<code>Scheme</code>、<code>Haskell</code>、<code>D</code>等）</li></ul><h2 id="三、Clang"><a href="#三、Clang" class="headerlink" title="三、Clang"></a>三、Clang</h2><ul><li><p>什么是<code>Clang</code>？ </p><ul><li><code>LLVM</code>项目的一个子项目 </li><li>基于<code>LLVM</code>架构的<code>C/C++/Objective-C</code>编译器前端 </li><li>官网：<a href="http://clang.llvm.org/">http://clang.llvm.org/</a></li></ul></li><li><p>相比于<code>GCC</code>，<code>Clang</code>具有如下优点 </p></li><li><p>编译速度快：在某些平台上，<code>Clang</code>的编译速度显著的快过<code>GCC</code>（<code>Debug</code>模式下编译<code>OC</code>速度比<code>GGC</code>快<code>3倍</code>）</p></li><li><p>占用内存小：<code>Clang</code>生成的<code>AST</code>所占用的内存是<code>GCC</code>的五分之一左右 </p></li><li><p>模块化设计：<code>Clang</code>采用基于库的模块化设计，易于<code>IDE</code>集成及其他用途的重用 </p></li><li><p>诊断信息可读性强：在编译过程中，<code>Clang</code>创建并保留了大量详细的元数据 (<code>metadata</code>)，有利于调试和错误报告 </p></li><li><p>设计清晰简单，容易理解，易于扩展增强</p></li></ul><h2 id="四、Clang与LLVM"><a href="#四、Clang与LLVM" class="headerlink" title="四、Clang与LLVM"></a>四、Clang与LLVM</h2><p> <img src="/images/20180912/Snip20180912_5.png"></p><h2 id="五、OC源文件的编译过程"><a href="#五、OC源文件的编译过程" class="headerlink" title="五、OC源文件的编译过程"></a>五、OC源文件的编译过程</h2><ul><li>命令行查看编译的过程：<code>$ clang -ccc-print-phases main.m</code><br> <img src="/images/20180912/Snip20180912_6.png"></li><li>查看<code>preprocessor</code>（预处理）的结果：<code>$ clang -E main.m</code></li></ul><h2 id="六、词法分析"><a href="#六、词法分析" class="headerlink" title="六、词法分析"></a>六、词法分析</h2><ul><li>词法分析，生成<code>Token</code>： <code>$ clang -fmodules -E -Xclang -dump-tokens main.m</code></li></ul><p> <img src="/images/20180912/Snip20180912_7.png"><br> <img src="/images/20180912/Snip20180912_8.png"></p><h2 id="七、语法树-AST"><a href="#七、语法树-AST" class="headerlink" title="七、语法树-AST"></a>七、语法树-AST</h2><ul><li>语法分析，生成语法树（<code>AST</code>，<code>Abstract Syntax Tree</code>）：<code> $ clang -fmodules -fsyntax-only -Xclang -ast-dump main.m</code></li></ul><p><img src="/images/20180912/Snip20180912_9.png"><br><img src="/images/20180912/Snip20180912_10.png"></p><h2 id="八、LLVM-IR"><a href="#八、LLVM-IR" class="headerlink" title="八、LLVM IR"></a>八、LLVM IR</h2><ul><li><code>LLVM IR</code>有3种表示形式（但本质是等价的，就好比水可以有气体、液体、固体3种形态）<ul><li><code>text</code>：便于阅读的文本格式，类似于汇编语言，拓展名<code>.ll</code>， <code>$ clang -S -emit-llvm main.m</code> </li><li><code>memory</code>：内存格式 </li><li><code>bitcode</code>：二进制格式，拓展名<code>.bc</code>， <code>$ clang -c -emit-llvm main.m</code></li></ul></li></ul><p><img src="/images/20180912/Snip20180912_11.png"></p><ul><li>IR基本语法<ul><li>注释以分号 <code>;</code> 开头 </li><li>全局标识符以<code>@</code>开头，局部标识符以<code>%</code>开头 </li><li><code>alloca</code>，在当前函数栈帧中分配内存 </li><li><code>i32</code>，<code>32bit</code>，4个字节的意思 </li><li><code>align</code>，内存对齐 </li><li><code>store</code>，写入数据 </li><li><code>load</code>，读取数据</li></ul></li><li>官方语法参考 <ul><li><a href="https://llvm.org/docs/LangRef.html">https://llvm.org/docs/LangRef.html</a></li></ul></li></ul><h2 id="九、源码下载"><a href="#九、源码下载" class="headerlink" title="九、源码下载"></a>九、源码下载</h2><ul><li><p>下载LLVM </p><ul><li><code>$ git clone https://git.llvm.org/git/llvm.git/</code></li><li>大小<code>746.2 MB</code>，仅供参考</li></ul></li><li><p>下载clang</p><ul><li><code>$ cd llvm/tools</code></li><li><code>$ git clone https://git.llvm.org/git/clang.git/</code> </li><li>大小<code>297.7 MB</code>，仅供参考</li></ul></li></ul><h2 id="十、源码编译"><a href="#十、源码编译" class="headerlink" title="十、源码编译"></a>十、源码编译</h2><ul><li><p>安装<code>cmake</code>和<code>ninja</code>（先安装<code>brew</code>，<a href="https://brew.sh/">https://brew.sh/</a>） </p><ul><li><code>$ brew install cmake</code></li><li><code>$ brew install ninja</code></li></ul></li><li><p><code>ninja</code>如果安装失败，可以直接从<code>github</code>获取<code>release</code>版放入<code>【/usr/local/bin】</code>中 </p><ul><li><a href="https://github.com/ninja-build/ninja/releases">https://github.com/ninja-build/ninja/releases</a></li></ul></li><li><p>在LLVM源码同级目录下新建一个<code>【llvm_build】</code>目录（最终会在<code>【llvm_build】</code>目录下生成<code>【build.ninja】</code>） </p><ul><li><code>$ cd llvm_build</code></li><li><code>$ cmake -G Ninja ../llvm -DCMAKE_INSTALL_PREFIX=LLVM的安装路径</code> </li><li>更多<code>cmake</code>相关选项，可以参考：<a href="https://llvm.org/docs/CMake.html">https://llvm.org/docs/CMake.html</a></li></ul></li><li><p>依次执行编译、安装指令 </p><ul><li><code>$ ninja</code></li><li>编译完毕后，<code>【llvm_build】</code>目录大概<code>21.05 G</code>（仅供参考） </li><li><code>$ ninja install</code> </li><li>安装完毕后，安装目录大概<code>11.92 G</code>（仅供参考）</li></ul></li><li><p>也可以生成<code>Xcode</code>项目再进行编译，但是速度很慢（可能需要1个多小时）</p></li><li><p>在<code>llvm</code>同级目录下新建一个<code>【llvm_xcode】</code>目录</p><ul><li><code>cd llvm_xcode</code> </li><li><code>$ cmake -G Xcode ../llvm</code></li></ul></li></ul><p><img src="/images/20180912/Snip20180912_12.png"><br><img src="/images/20180912/Snip20180912_13.png"><br><img src="/images/20180912/Snip20180912_14.png"></p><h2 id="十一、应用与实践"><a href="#十一、应用与实践" class="headerlink" title="十一、应用与实践"></a>十一、应用与实践</h2><ul><li><p><code>libclang</code>、<code>libTooling</code> </p><ul><li>官方参考：<a href="https://clang.llvm.org/docs/Tooling.html">https://clang.llvm.org/docs/Tooling.html</a> </li><li>应用：语法树分析、语言转换等</li></ul></li><li><p><code>Clang</code>插件开发 </p><ul><li>官方参考<ul><li><a href="https://clang.llvm.org/docs/ClangPlugins.html">https://clang.llvm.org/docs/ClangPlugins.html</a> </li><li><a href="https://clang.llvm.org/docs/ExternalClangExamples.html">https://clang.llvm.org/docs/ExternalClangExamples.html</a> </li><li><a href="https://clang.llvm.org/docs/RAVFrontendAction.html">https://clang.llvm.org/docs/RAVFrontendAction.html</a></li></ul></li><li>应用：代码检查（命名规范、代码规范）等</li></ul></li><li><p><code>Pass</code>开发 p</p><ul><li>官方参考：<a href="https://llvm.org/docs/WritingAnLLVMPass.html">https://llvm.org/docs/WritingAnLLVMPass.html</a> </li><li>应用：代码优化、代码混淆等</li></ul></li><li><p>开发新的编程语言 </p><ul><li><a href="https://llvm-tutorial-cn.readthedocs.io/en/latest/index.html">https://llvm-tutorial-cn.readthedocs.io/en/latest/index.html</a> </li><li><a href="https://kaleidoscope-llvm-tutorial-zh-cn.readthedocs.io/zh_CN/latest/">https://kaleidoscope-llvm-tutorial-zh-cn.readthedocs.io/zh_CN&#x2F;latest&#x2F;</a></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LLVM </tag>
            
            <tag> 编译器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CocoaPods私有库使用Tips</title>
      <link href="/posts/a3aab850.html"/>
      <url>/posts/a3aab850.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-pod-lib-lint-和-pod-spec-lint-命令的区别"><a href="#1-pod-lib-lint-和-pod-spec-lint-命令的区别" class="headerlink" title="1.pod lib lint 和 pod spec lint 命令的区别"></a>1.<code>pod lib lint</code> 和 <code>pod spec lint</code> 命令的区别</h2><ul><li><code>pod lib lint</code>是只从本地验证你的pod能否通过验证;</li><li><code>pod spec lint</code>是从本地和远程验证你的pod能否通过验证;</li></ul><h2 id="2-私有pod的验证"><a href="#2-私有pod的验证" class="headerlink" title="2.私有pod的验证"></a>2.私有<code>pod</code>的验证</h2><p>使用<code>pod spec lint</code>去验证私有库能否通过验证时应该要添加<code>--sources</code>选项，不然会出现找不到<code>repo</code>的错误:</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod spec lint --sources=<span class="string">&#x27;私有仓库repo地址,https://github.com/CocoaPods/Specs&#x27;</span></span><br></pre></td></tr></table></figure><span id="more"></span><h2 id="3-subspec"><a href="#3-subspec" class="headerlink" title="3.subspec"></a>3.<code>subspec</code></h2><p>为了让自己的<code>Pod</code>被导入时显示出良好的文件层划分，<code>subspec</code>是必须的。<br>若<code>subspec</code>要依赖其它的<code>subspec</code>，则<code>subspec</code>的<code>dependency</code>后面接的不是目录路径，而是<code>specA/specB</code>这种<code>spec</code>关系；</p><h2 id="4-私有库引用私有库的问题"><a href="#4-私有库引用私有库的问题" class="headerlink" title="4.私有库引用私有库的问题"></a>4.私有库引用私有库的问题</h2><p>在私有库引用了私有库的情况下，在验证和推送私有库的情况下都要加上所有的资源地址，不然<code>Pod</code>会默认从官方<code>repo</code>查询。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pod spec lint --sources=<span class="string">&#x27;私有仓库repo地址,https://github.com/CocoaPods/Specs&#x27;</span></span><br><span class="line">pod repo push 本地repo名 podspec名 --sources=<span class="string">&#x27;私有仓库repo地址,https://github.com/CocoaPods/Specs</span></span><br></pre></td></tr></table></figure><h2 id="5-引用自己或第三方的framework或-a文件时"><a href="#5-引用自己或第三方的framework或-a文件时" class="headerlink" title="5.引用自己或第三方的framework或.a文件时"></a>5.引用自己或第三方的<code>framework</code>或<code>.a</code>文件时</h2><p>在<code>podsepc</code>中应该这样写:</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s.ios.vendored_frameworks = <span class="string">&quot;xxx/**/*.framework&quot;</span></span><br><span class="line">s.ios.vendored_libraries = <span class="string">&quot;xxx/**/*.a”</span></span><br></pre></td></tr></table></figure><h2 id="6-引用静态库：-ios-library。去掉头尾的lib，用”-”分割"><a href="#6-引用静态库：-ios-library。去掉头尾的lib，用”-”分割" class="headerlink" title="6.引用静态库：(.ios).library。去掉头尾的lib，用”,”分割"></a>6.引用静态库：<code>(.ios).library</code>。去掉头尾的<code>lib</code>，用”<code>,</code>”分割</h2><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/<span class="regexp">/ 引用libxml2.lib和libz.lib.</span></span><br><span class="line"><span class="regexp">spec.libraries =  &#x27;xml2&#x27;, &#x27;z&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="7-引用公有framework：-ios-framework-用”-”分割-去掉尾部的”-framework”"><a href="#7-引用公有framework：-ios-framework-用”-”分割-去掉尾部的”-framework”" class="headerlink" title="7.引用公有framework：(.ios).framework. 用”,”分割. 去掉尾部的”.framework”"></a>7.引用公有framework：<code>(.ios).framework</code>. 用”<code>,</code>”分割. 去掉尾部的”<code>.framework</code>”</h2><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spec.frameworks = <span class="string">&#x27;UIKit&#x27;</span>,<span class="string">&#x27;SystemConfiguration&#x27;</span>, <span class="string">&#x27;Accelerate&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="8-引用自己生成的framework：-ios-vendored-frameworks。用”-”分割-路径写从-podspec所在目录为根目录的相对路径-ps-这个不要省略-framework"><a href="#8-引用自己生成的framework：-ios-vendored-frameworks。用”-”分割-路径写从-podspec所在目录为根目录的相对路径-ps-这个不要省略-framework" class="headerlink" title="8.引用自己生成的framework：(.ios).vendored_frameworks。用”,”分割,路径写从.podspec所在目录为根目录的相对路径 ps:这个不要省略.framework"></a>8.引用自己生成的framework：<code>(.ios).vendored_frameworks</code>。用”<code>,</code>”分割,路径写从<code>.podspec</code>所在目录为根目录的相对路径 ps:这个不要省略<code>.framework</code></h2><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spec.ios.vendored_frameworks = <span class="string">&#x27;Pod/Assets/*.framework&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="9-引用自己生成的-a文件-添加到Pod-Assets文件夹里-Demo的Example文件夹里也需要添加一下-不然找不到"><a href="#9-引用自己生成的-a文件-添加到Pod-Assets文件夹里-Demo的Example文件夹里也需要添加一下-不然找不到" class="headerlink" title="9.引用自己生成的.a文件, 添加到Pod/Assets文件夹里. Demo的Example文件夹里也需要添加一下, 不然找不到"></a>9.引用自己生成的<code>.a</code>文件, 添加到<code>Pod/Assets</code>文件夹里. Demo的Example文件夹里也需要添加一下, 不然找不到</h2><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spec.ios.vendored_libraries = <span class="string">&#x27;Pod/Assets/*.a&#x27;</span></span><br></pre></td></tr></table></figure><p>在提交到私有仓库的时候需要加上<code>--use-libraries</code></p><h2 id="10-私有库中添加资源-图片、音视频等"><a href="#10-私有库中添加资源-图片、音视频等" class="headerlink" title="10.私有库中添加资源(图片、音视频等)"></a>10.私有库中添加资源(图片、音视频等)</h2><p>方法共有三种:</p><ul><li>第一种</li></ul><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spec.resources = [<span class="string">&quot;Images/*.png&quot;</span>, <span class="string">&quot;Sounds/*&quot;</span>]</span><br></pre></td></tr></table></figure><p>但是这些资源会在打包的时候直接拷贝的<code>App</code>的<code>Bundle</code>中，这样说不定会和其它资源产生命名冲突；</p><ul><li>第二种</li></ul><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spec.resource = <span class="string">&quot;Resources/MyLibrary.bundle&quot;</span></span><br></pre></td></tr></table></figure><p> 把资源都放在<code>bundle</code>中，然后打包时候这个<code>bundle</code>会直接拷贝进<code>App</code>的<code>mainBundle</code>中。使用的时候在<code>mainBundle</code>中查找这个<code>bundle</code>然后再搜索具体资源:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">NSURL *bundleURL = [[NSBundle mainBundle] URLForResource:@&quot;MyLibrary&quot; withExtension:@&quot;bundle&quot;];</span><br><span class="line">NSBundle *bundle = [NSBundle bundleWithURL:bundleURL];</span><br><span class="line">UIImage *imgage = [UIImage imageNamed:icon inBundle:bundle compatibleWithTraitCollection:nil];</span><br></pre></td></tr></table></figure><ul><li>第三种</li></ul><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">spec.resource_bundles = &#123;</span><br><span class="line"><span class="string">&#x27;MyLibrary&#x27;</span> =&gt; [<span class="string">&#x27;Resources/*.png&#x27;</span>],</span><br><span class="line"><span class="string">&#x27;OtherResources&#x27;</span> =&gt; [<span class="string">&#x27;OtherResources/*.png&#x27;</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 这种方法利用<code>framework</code>的命名空间，有效防止了资源冲突。<br>使用方法是先拿到最外面的<code>bundle</code>，然后再去找下面指定名字的<code>bundle</code> 对象，再搜索具体资源:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">NSBundle *bundle = [NSBundle bundleForClass:[self class]];</span><br><span class="line">NSURL *bundleURL = [bundle URLForResource:@&quot;MyLibrary&quot; withExtension:@&quot;bundle&quot;];</span><br><span class="line">NSBundle *resourceBundle = [NSBundle bundleWithURL: bundleURL];</span><br><span class="line">UIImage *imgage = [UIImage imageNamed:icon inBundle:resourceBundle compatibleWithTraitCollection:nil];</span><br></pre></td></tr></table></figure><h2 id="11-如果私有库添加了静态库或者dependency用了静态库"><a href="#11-如果私有库添加了静态库或者dependency用了静态库" class="headerlink" title="11.如果私有库添加了静态库或者dependency用了静态库"></a>11.如果私有库添加了静态库或者<code>dependency</code>用了静态库</h2><p>那么执行<code>pod lib lint</code>还有<code>pod spec lint</code>时候需要加上<code>—user-libraries</code>选项,否则会出现<code>&#39;The &#39;Pods&#39; target has transitive dependencies</code>错误</p><h2 id="12-如果私有库只引用其他库的subspec"><a href="#12-如果私有库只引用其他库的subspec" class="headerlink" title="12.如果私有库只引用其他库的subspec"></a>12.如果私有库只引用其他库的<code>subspec</code></h2><p>只需要依赖想依赖的<code>subspec</code>，不用管主<code>spec</code>（因为依赖<code>subspec</code>必然要依赖主<code>spec</code>）</p><h2 id="13-私有库已经通过验证并传到私有repo也能通过pod-search，但是就是pod-install失败"><a href="#13-私有库已经通过验证并传到私有repo也能通过pod-search，但是就是pod-install失败" class="headerlink" title="13.私有库已经通过验证并传到私有repo也能通过pod search，但是就是pod install失败"></a>13.私有库已经通过验证并传到私有<code>repo</code>也能通过<code>pod search</code>，但是就是<code>pod install</code>失败</h2><p>这时候只要执行<code>pod update</code></p><h2 id="14-提交到私有仓库的之前可以先验证一下-有问题就修复它-验证过了在提交"><a href="#14-提交到私有仓库的之前可以先验证一下-有问题就修复它-验证过了在提交" class="headerlink" title="14.提交到私有仓库的之前可以先验证一下, 有问题就修复它, 验证过了在提交"></a>14.提交到私有仓库的之前可以先验证一下, 有问题就修复它, 验证过了在提交</h2><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod spec lint <span class="title class_">VenderName</span>.podspec --verbose</span><br></pre></td></tr></table></figure><p>打好<code>tag</code>, 推到<code>Git</code>里去后, 才可以在测试的项目里的<code>Podfile</code>里引用这个库, 然后<code>pod update VenderName --no-repo-update</code>, 测试通过了, 在提交到私有仓库里</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod <span class="string">&#x27;VenderName&#x27;</span>, <span class="symbol">:podspec</span> =&gt; <span class="string">&#x27;VenderName.podspec的路径地址&#x27;</span></span><br></pre></td></tr></table></figure><p>还可以指定引用某个分支的代码</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod <span class="string">&#x27;VenderName&#x27;</span>, <span class="symbol">:git</span> =&gt; <span class="string">&#x27;https://git.coding.net/CodingZero/VenderName.git&#x27;</span>, <span class="symbol">:branch</span> =&gt; <span class="string">&#x27;develop&#x27;</span></span><br></pre></td></tr></table></figure><p>提交到私有仓库的时候还可以忽略警告类的错误, 愣是要提交. 在后面加上<code>--allow-warnings</code></p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod repo push <span class="title class_">LYSpecs</span> <span class="title class_">VenderName</span>.podspec --allow-warnings</span><br></pre></td></tr></table></figure><p>如果有添加新的文件, 需要更新下引索, <code>Demo</code>里才可以识别</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod update <span class="title class_">VenderName</span> --no-repo-update</span><br></pre></td></tr></table></figure><h2 id="15-使用的时候还可以通过直接指定地址-tag-or-分支-or-commit-的方式来引入-这样就可以不用走发布流程了-也不需要添加源了"><a href="#15-使用的时候还可以通过直接指定地址-tag-or-分支-or-commit-的方式来引入-这样就可以不用走发布流程了-也不需要添加源了" class="headerlink" title="15.使用的时候还可以通过直接指定地址 + tag or 分支 or commit 的方式来引入, 这样就可以不用走发布流程了. 也不需要添加源了."></a>15.使用的时候还可以通过直接指定地址 + <code>tag</code> or <code>分支</code> or <code>commit</code> 的方式来引入, 这样就可以不用走发布流程了. 也不需要添加源了.</h2><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pod <span class="string">&#x27;VenderName&#x27;</span>, <span class="symbol">:git</span> =&gt; <span class="string">&#x27;https://git.coding.net/CodingZero/VenderName.git&#x27;</span>, <span class="symbol">:tag</span> =&gt; <span class="string">&#x27;0.8.1&#x27;</span></span><br><span class="line"></span><br><span class="line">pod <span class="string">&#x27;VenderName&#x27;</span>, <span class="symbol">:git</span> =&gt; <span class="string">&#x27;https://git.coding.net/CodingZero/VenderName.git&#x27;</span>, <span class="symbol">:branch</span> =&gt; <span class="string">&#x27;develop&#x27;</span></span><br><span class="line"></span><br><span class="line">pod <span class="string">&#x27;VenderName&#x27;</span>, <span class="symbol">:git</span> =&gt; <span class="string">&#x27;https://git.coding.net/CodingZero/VenderName.git&#x27;</span>, <span class="symbol">:commit</span> =&gt; <span class="string">&#x27;0812fe81319af2411233&#x27;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CocoaPods </tag>
            
            <tag> pod </tag>
            
            <tag> 私有库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CocoaPods私有库Steps</title>
      <link href="/posts/759f5f2d.html"/>
      <url>/posts/759f5f2d.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-创建私有仓库"><a href="#1-创建私有仓库" class="headerlink" title="1.创建私有仓库"></a>1.创建私有仓库</h2><p>先<code>coding.net</code>、<code>OSChina</code>、<code>GitHub</code>或者自己搭建的<code>Git</code>服务器上创建一个私有仓库，然后在本地添加仓库</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod repo add <span class="title class_">LYSpecs</span> <span class="symbol">https:</span>/<span class="regexp">/git.coding.net/</span><span class="title class_">CodingZero</span>/<span class="title class_">LYSpecs</span>.git</span><br></pre></td></tr></table></figure><span id="more"></span><h2 id="2-创建私有库"><a href="#2-创建私有库" class="headerlink" title="2.创建私有库"></a>2.创建私有库</h2><p>创建私有库模板</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod lib create <span class="title class_">VenderName</span></span><br></pre></td></tr></table></figure><ul><li>第一个问题是问你选择<code>Swift</code>还是<code>Objc</code>构建项目。<code>eg: ObjC </code></li></ul> <figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hat language <span class="keyword">do</span> you want to use?? [ <span class="title class_">Swift</span> / <span class="title class_">Obj</span>C ]</span><br><span class="line"> &gt; <span class="title class_">Obj</span>C</span><br></pre></td></tr></table></figure><ul><li>第二个问题问你是否需要创建一个Demo项目<code>eg: Yes</code></li></ul> <figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Would</span> you like to <span class="keyword">include</span> a demo application with your library? [ <span class="title class_">Yes</span> / <span class="title class_">No</span> ]</span><br><span class="line"> &gt; <span class="title class_">Yes</span></span><br></pre></td></tr></table></figure><ul><li>第三个问题让你是否选择一个测试框架<code>eg: None</code></li></ul> <figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Which</span> testing frameworks will you use? [ <span class="title class_">Specta</span> / <span class="title class_">Kiwi</span> / <span class="title class_">None</span> ]</span><br><span class="line">&gt; <span class="title class_">None</span></span><br></pre></td></tr></table></figure><ul><li>第四个问题是否基于View测试<code>eg: No</code></li></ul> <figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Would</span> you like to <span class="keyword">do</span> view based testing? [ <span class="title class_">Yes</span> / <span class="title class_">No</span> ]</span><br><span class="line">&gt; <span class="title class_">No</span></span><br></pre></td></tr></table></figure><ul><li>第五个问题是询问 类的前缀<code>eg: LY</code></li></ul> <figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">What</span> is your <span class="keyword">class</span> prefix?</span><br><span class="line">&gt; <span class="variable constant_">LY</span></span><br></pre></td></tr></table></figure><h2 id="3-更新发布私有库"><a href="#3-更新发布私有库" class="headerlink" title="3.更新发布私有库"></a>3.更新发布私有库</h2><ul><li>提交代码</li></ul> <figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add -A &amp;&amp; git commit -m <span class="string">&quot;Release 1.0.0&quot;</span></span><br></pre></td></tr></table></figure><ul><li>打<code>tag</code></li></ul> <figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git tag <span class="string">&#x27;1.0.0&#x27;</span></span><br></pre></td></tr></table></figure><ul><li>把<code>tag</code>推到远程仓库</li></ul> <figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push --tags</span><br></pre></td></tr></table></figure><ul><li>将本地的<code>master</code>分支推送到远程仓库</li></ul> <figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin master</span><br></pre></td></tr></table></figure><ul><li>提交到私有仓库</li></ul> <figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> pod repo push <span class="title class_">LYSpecs</span> <span class="title class_">VenderName</span>.podspec --allow-warnings --verbose</span><br><span class="line">/<span class="regexp">/ --allow-warnings : 允许 警告，有一些警告是代码自身带的。</span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ --use-libraries  : 私有库、静态库引用的时候加上</span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ —-verbose ： lint显示详情</span></span><br></pre></td></tr></table></figure><h2 id="4-使用私有库"><a href="#4-使用私有库" class="headerlink" title="4.使用私有库"></a>4.使用私有库</h2><ul><li>用的时候需要在<code>Podfile</code>里添加源</li></ul> <figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> /<span class="regexp">/ GitHub地址</span></span><br><span class="line"><span class="regexp">source &#x27;https:/</span><span class="regexp">/github.com/</span><span class="title class_">CocoaPods</span>/<span class="title class_">Specs</span>.git<span class="string">&#x27;</span></span><br><span class="line"><span class="string"># ...相关库</span></span><br><span class="line"><span class="string">// 私有库地址</span></span><br><span class="line"><span class="string">source &#x27;</span><span class="symbol">https:</span>/<span class="regexp">/git.coding.net/</span><span class="title class_">CodingZero</span>/<span class="title class_">LYSpecs</span>.git<span class="string">&#x27;</span></span><br><span class="line"><span class="string"># ...私有库</span></span><br></pre></td></tr></table></figure><ul><li>用的时候在Podfile里引用</li></ul> <figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod <span class="string">&#x27;VenderName&#x27;</span></span><br></pre></td></tr></table></figure><ul><li>开发模式下测试Pod库的代码</li></ul> <figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod <span class="string">&#x27;VenderName&#x27;</span>, <span class="symbol">:path</span> =&gt; <span class="string">&#x27;../&#x27;</span> <span class="comment"># 指定路径</span></span><br></pre></td></tr></table></figure><p> 然后在Example工程目录下执行<code>pod update</code>命令安装依赖，打开项目工程，可以看到库文件都被加载到<code>Pods</code>子项目中了<br>不过它们并没有在<code>Pods</code>目录下，而是跟测试项目一样存在于<code>Development Pods/VenderName </code>中，这是因为我们是在本地测试，而没有把<code>podspec</code>文件添加到<code>Spec Repo</code>中的缘故。</p><h2 id="5-podspec文件配置说明"><a href="#5-podspec文件配置说明" class="headerlink" title="5.podspec文件配置说明"></a>5.<code>podspec</code>文件配置说明</h2><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Be sure to run `pod lib lint VenderName.podspec&#x27; to ensure this is a</span></span><br><span class="line"><span class="comment"># valid spec before submitting.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Any lines starting with a # are optional, but their use is encouraged</span></span><br><span class="line"><span class="comment"># To learn more about a Podspec see http://guides.cocoapods.org/syntax/podspec.html</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Pod::Spec</span>.new <span class="keyword">do</span> |<span class="params">s</span>|</span><br><span class="line">  <span class="comment">#名称</span></span><br><span class="line">  s.name             = <span class="string">&#x27;VenderName&#x27;</span></span><br><span class="line">  <span class="comment">#版本号</span></span><br><span class="line">  s.version          = <span class="string">&#x27;0.1.0&#x27;</span></span><br><span class="line">  <span class="comment">#简介</span></span><br><span class="line">  s.summary          = <span class="string">&#x27;这个是我的私有库项目Demo.&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># This description is used to generate tags and improve search results.</span></span><br><span class="line"><span class="comment">#   * Think: What does it do? Why did you write it? What is the focus?</span></span><br><span class="line"><span class="comment">#   * Try to keep it short, snappy and to the point.</span></span><br><span class="line"><span class="comment">#   * Write the description between the DESC delimiters below.</span></span><br><span class="line"><span class="comment">#   * Finally, don&#x27;t worry about the indent, CocoaPods strips it!</span></span><br><span class="line"></span><br><span class="line">  s.description      = <span class="string">&lt;&lt;-DESC</span></span><br><span class="line"><span class="string">  这个是教程的 私有库项目 学习Demo. （主要：比s.summary要长）</span></span><br><span class="line"><span class="string">                       DESC</span></span><br><span class="line">  <span class="comment">#主页,这里要填写可以访问到的地址，不然验证不通过</span></span><br><span class="line">  s.homepage         = <span class="string">&#x27;https://coding.net/CodingZero/VenderName&#x27;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># s.screenshots     = &#x27;www.example.com/screenshots_1&#x27;, &#x27;www.example.com/screenshots_2&#x27;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">#开源协议</span></span><br><span class="line"></span><br><span class="line">  s.license          =   &#123; <span class="symbol">:type</span> =&gt; <span class="string">&#x27;MIT&#x27;</span>, <span class="symbol">:file</span> =&gt; <span class="string">&#x27;LICENSE&#x27;</span> &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">#作者</span></span><br><span class="line">  s.author           = &#123; <span class="string">&#x27;DeveloperLY&#x27;</span> =&gt; <span class="string">&#x27;coderyliu@gmail.com&#x27;</span> &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">#项目地址，这里不支持ssh的地址，验证不通过，只支持HTTP和HTTPS，最好使用HTTPS。</span></span><br><span class="line">  <span class="comment">#这里的s.source须指向存放源代码的链接地址，而不是托管spec文件的repo地址</span></span><br><span class="line">  s.source           = &#123; <span class="symbol">:git</span> =&gt; <span class="string">&#x27;https://coding.net/CodingZero/VenderName.git&#x27;</span>, <span class="symbol">:tag</span> =&gt; <span class="string">&quot;0.1.0&quot;</span> &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">#s.social_media_url = &#x27;http://weibo.com/lycoder&#x27;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">#支持的平台及版本</span></span><br><span class="line">  s.ios.deployment_target = <span class="string">&#x27;7.0&#x27;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">#代码源文件地址，**/*表示Classes目录及其子目录下所有文件，如果有多个目录下则</span></span><br><span class="line">  <span class="comment">#用逗号分开，如果需要在项目中分组显示，这里也要做相应的设置</span></span><br><span class="line"></span><br><span class="line">  s.source_files = <span class="string">&quot;VenderName/Classes/**/*&quot;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">#资源文件地址</span></span><br><span class="line">  <span class="comment"># s.resource_bundles = &#123;</span></span><br><span class="line">  <span class="comment">#   &#x27;MyLib&#x27; =&gt; [&#x27;VenderName/Assets/*.png&#x27;]</span></span><br><span class="line">  <span class="comment"># &#125;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">#公开头文件地址</span></span><br><span class="line">  <span class="comment">#s.public_header_files = &#x27;VenderName/Classes/**/*.h&#x27;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">#所需的framework，多个用逗号隔开</span></span><br><span class="line">  s.frameworks = <span class="string">&#x27;UIKit&#x27;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">#依赖关系，该项目所依赖的其他库，如果有多个需要填写多个s.dependency</span></span><br><span class="line">  <span class="comment"># s.dependency &#x27;AFNetworking&#x27;, &#x27;~&gt; 2.3&#x27;</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CocoaPods </tag>
            
            <tag> pod </tag>
            
            <tag> 私有库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot 快速入门</title>
      <link href="/posts/f573843c.html"/>
      <url>/posts/f573843c.html</url>
      
        <content type="html"><![CDATA[<h2 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h2><p><code>Spring Boot</code>是由<code>Pivotal</code>团队提供的全新框架，其设计目的是用来简化新<code>Spring</code>应用的初始搭建以及开发过程。该框架使用了特定的方式来进行配置，从而使开发人员不再需要定义样板化的配置。通过这种方式，<code>Spring Boot</code>致力于在蓬勃发展的快速应用开发领域<code>（rapid application development）</code>成为领导者。</p><span id="more"></span><h2 id="二、Spring-Boot-的主要优点："><a href="#二、Spring-Boot-的主要优点：" class="headerlink" title="二、Spring Boot 的主要优点："></a>二、Spring Boot 的主要优点：</h2><ul><li>快速构建独立的<code>Spring</code>应用程序</li><li>开箱即用，提供各种默认配置来简化项目配置</li><li>内嵌式容器简化<code>Web</code>项目，嵌入<code>Tomcat</code>、<code>Gradle</code>，无需部署<code>WAR</code>包</li><li>提供生产就绪功能，如指标，健康检查和外部配置</li><li>简化<code>Maven</code>及<code>Gradle</code>配置</li><li>没有冗余代码生成和XML配置的要求</li><li>对主流开发框架和工具链做无配置集成</li></ul><h2 id="三、系统环境"><a href="#三、系统环境" class="headerlink" title="三、系统环境"></a>三、系统环境</h2><ul><li>Java 1.8.0_112</li><li>Spring Boot1.5.4</li><li>IntelliJ IDEA  2017.1.3</li></ul><h2 id="四、快速构建项目"><a href="#四、快速构建项目" class="headerlink" title="四、快速构建项目"></a>四、快速构建项目</h2><h3 id="1-使用SPRING-INITIALIZR工具生成基础项目"><a href="#1-使用SPRING-INITIALIZR工具生成基础项目" class="headerlink" title="1. 使用SPRING INITIALIZR工具生成基础项目"></a>1. 使用<code>SPRING INITIALIZR</code>工具生成基础项目</h3><p>1.1 打开浏览器：<code>http://start.spring.io/</code></p><p>1.2 选择构建工具<code>Maven Project</code>、<code>Java</code>和<code>Spring Boot</code>版本<code>1.5.4</code>以及填 写一下工程基本信息：<br><img src="/images/20170706/Snip20170706_1.png" alt="SPRING INITIALIZR"></p><p>1.3 点击<code>Generate Project</code>下载项目压缩包</p><h3 id="2-使用IDEA将解压的项目包以Maven方式导入"><a href="#2-使用IDEA将解压的项目包以Maven方式导入" class="headerlink" title="2. 使用IDEA将解压的项目包以Maven方式导入"></a>2. 使用<code>IDEA</code>将解压的项目包以<code>Maven</code>方式导入</h3><p>2.1 解压刚才下载的项目压缩包</p><p>2.2 打开<code>IDEA</code>在菜单中选择<code>File</code> -&gt; <code>New</code> -&gt; <code>Project from Existing Sources...</code></p><p>2.3 选择解压的项目文件夹，点击<code>Opne</code></p><p>2.4 点击<code>Import project from external model</code>并选择<code>Maven</code>，点击<code>Finish </code>到底为止。</p><h2 id="五、基础项目结构解析"><a href="#五、基础项目结构解析" class="headerlink" title="五、基础项目结构解析"></a>五、基础项目结构解析</h2><p><img src="/images/20170706/Snip20170706_2.png" alt="基础项目结构"></p><p>通过上述步骤构建了基础项目，如上图所示：</p><ul><li><code>src/main/java</code>下的程序入口：<code>SpringBootDemoApplication</code></li><li><code>src/main/resources</code>下的配置文件：<code>application.properties</code></li><li><code>src/test/</code>下的测试入口：<code>SpringBootDemoApplicationTests</code></li></ul><p>生成的<code>SpringBootDemoApplication</code>和<code>SpringBootDemoApplicationTests</code>类都可以直接运行来启动当前创建的项目，由于目前该项目未配合任何数据访问或<code>Web</code>模块，程序会在加载完<code>Spring</code>之后结束运行。</p><h2 id="六、引入Web模块"><a href="#六、引入Web模块" class="headerlink" title="六、引入Web模块"></a>六、引入Web模块</h2><p>当前的<code>pom.xml</code>内容如下，仅引入了两个模块：<br/></p><ul><li><code>spring-boot-starter</code>：核心模块，包括自动配置支持、日志和YAML</li><li><code>spring-boot-starter-test</code>：测试模块，包括<code>JUnit</code>、<code>Hamcrest</code>、<code>Mockito</code><br/></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><p>引入Web模块，需添加<code>spring-boot-starter-web</code>模块：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><br/>## 七、编写Hello World服务 * 创建`package`命名为`net.developerly.web`（根据实际情况修改） * 创建`ExampleController`类，内容如下 <br/> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExampleController</span> &#123;</span><br><span class="line">   <span class="meta">@RequestMapping(&quot;/hello&quot;)</span></span><br><span class="line">   <span class="keyword">public</span> String <span class="title function_">index</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="string">&quot;Hello World&quot;</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>启动主程序，打开浏览器访问<code>http://localhost:8080/hello</code>，可以看到页面输出<code>Hello World</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iOS项目工程中启动Unity项目工程</title>
      <link href="/posts/2fad9518.html"/>
      <url>/posts/2fad9518.html</url>
      
        <content type="html"><![CDATA[<h2 id="一、Unity-3D导出iOS项目"><a href="#一、Unity-3D导出iOS项目" class="headerlink" title="一、Unity 3D导出iOS项目"></a>一、Unity 3D导出iOS项目</h2><ul><li>将Unity3D 导出 iOS的项目<ul><li>详细步骤…</li><li>导出目录<br/><br>  <img src="/images/20160830/0000001.jpg" alt="Unity导出iOS目录"><br/></li></ul></li><li>注）U3D的所有相关设置，都在U3D这边设置，设置好后导出iOS项目<br/><span id="more"></span></li></ul><h2 id="二、将导出的一些文件导入到已有的iOS工程项目中"><a href="#二、将导出的一些文件导入到已有的iOS工程项目中" class="headerlink" title="二、将导出的一些文件导入到已有的iOS工程项目中"></a>二、将导出的一些文件导入到已有的iOS工程项目中</h2><ul><li>将<code>Classes</code> 和 <code>Libraries</code> 文件夹 选择 <code>Create groups</code> 方式导入已有的iOS工程中<br/><br>  <img src="/images/20160830/Snip20160830_2.png" alt="导入Classes和Libraries"><br/></li><li>将<code>Data</code> 文件夹 选择 <code>Create folder references</code> 方式导入的已有的iOS工程中<br/><br>  <img src="/images/20160830/Snip20160830_3.png" alt="导入Data"><br/></li><li>导入之后的目录结构<br/><br>  <img src="/images/20160830/Snip20160830_4.png" alt="导入之后的目录"><br/></li></ul><h2 id="三、删除Native下所有的-h文件的引用"><a href="#三、删除Native下所有的-h文件的引用" class="headerlink" title="三、删除Native下所有的.h文件的引用"></a>三、删除Native下所有的.h文件的引用</h2><p>注意：<code>Native</code> 下面不仅有<code>.h</code>文件，还有<code>.cpp</code>文件，这里只需要删除所有的<code>.h</code>文件<br><br/><br><img src="/images/20160830/Snip20160830_5.png" alt="删除Native下所有的.h文件的引用"><br><br/><br><img src="/images/20160830/Snip20160830_6.png" alt="删除Native下所有的.h文件的引用"><br><br/></p><h2 id="四、删除libil2cpp引用"><a href="#四、删除libil2cpp引用" class="headerlink" title="四、删除libil2cpp引用"></a>四、删除libil2cpp引用</h2><br/>![删除libil2cpp引用](/images/20160830/Snip20160830_9.png)<br/>![删除libil2cpp引用](/images/20160830/Snip20160830_6.png)<br/>## 五、添加引用类库* 添加引用库（有部分是iOS），有三个是`optional` ~<br/>![添加引用库](/images/20160830/Snip20160830_7.png)<br/>## 六、Build Settings* `Build Options` -> `Enable Bitcode` = `NO`<br/>    ![Build Settings](/images/20160830/Snip20160830_1.png)<br/>* `Linking` -> `Other Linker Flags` 添加`-weak_framework` `CoreMotion` `-weak-lSystem`<br/>    ![Build Settings](/images/20160830/Snip20160830_11.png)<br/>* 在`Search Paths`->`Header Search Paths`添加下图中的头文件引用<br/>    ![Build Settings](/images/20160830/Snip20160830_12.png)<br/>* 在`Search Paths`->`Library Search Paths` 添加图中路径<br/>    ![Build Settings](/images/20160830/Snip20160830_13.png)<br/>* 在`Apple LLVM 7.1 - Custom Compiler Flags` -> `Other C Flags` 中添加 `-DINIT_SCRIPTING_BACKEND=1` 同时会在 `Other C++ Flags`中出现<br/>    ![Build Settings](/images/20160830/Snip20160830_14.png)<br/>* 修改`Apple LLVM 7.1 - Language` -> `C Language Dialect` 值改为C99<br/>    ![Build Settings](/images/20160830/Snip20160830_15.png)<br/>* 修改`Apple LLVM 7.1 - Language` -> `Precompile Prefix Header` 的值为Yes<br/>    ![Build Settings](/images/20160830/Snip20160830_16.png)<br/>* 在`Apple LLVM 7.1 - Language - C++`中做如下设置<br/>    ![Build Settings](/images/20160830/Snip20160830_17.png)<br/>* 在`Apple LLVM 7.1 - Warnings - Objective C`中做如下更改<br/>    ![Build Settings](/images/20160830/Snip20160830_18.png)<br/>* 在`User-Defined` 中添加如下    * `GCC_THUMB_SUPPORT` = `NO`    * `GCC_USE_INDIRECT_FUNCTION_CALLS` = `NO`    * `UNITY_RUNTIME_VERSION` = `5.4.0f3`    * `UNITY_SCRIPTING_BACKEND` = `il2cpp`<br/>    ![Build Settings](/images/20160830/Snip20160830_8.png)<br/>## 七、修改PCH文件* 将`Unity`->`Classes`下面的`Perfix.pch`中的代码全部拷贝到主工程项目的`PCH`中，并且在主工程项目的`PCH`中添加 `#import "UnityAppController.h"`<br/>    ![修改PCH文件](/images/20160830/Snip20160830_10.png)<br/>    ![修改PCH文件](/images/20160830/Snip20160830_19.png)<br/><h2 id="八、处理主工程和Unity的main文件"><a href="#八、处理主工程和Unity的main文件" class="headerlink" title="八、处理主工程和Unity的main文件"></a>八、处理主工程和Unity的<code>main</code>文件</h2><ul><li>处理iOS主工程中的<code>main.m</code>文件，将 <code>.m</code> 改为 <code>.mm</code></li><li>将<code>Unity</code>下<code>Classes</code>下的<code>main.mm</code>文件中的内容拷贝到主工程的<code>main</code>文件中，并进行如下修改：<br/><br> <img src="/images/20160830/Snip20160830_20.png" alt="处理主工程和Unity的`main`文件"><br/></li><li>在<code>Build Phases</code>中移除<code>Unity</code>-&gt;<code>Classes</code>下的<code>main.mm</code>文件<br/></li></ul><h2 id="九、处理UnityAppController-h文件"><a href="#九、处理UnityAppController-h文件" class="headerlink" title="九、处理UnityAppController.h文件"></a>九、处理<code>UnityAppController.h</code>文件</h2><p><code>UnityAppController.h</code>做如下修改<br/><br>    <img src="/images/20160830/Snip20160830_21.png" alt="处理`UnityAppController.h`文件"><br/></p><h2 id="十、处理AppDelegate这个类"><a href="#十、处理AppDelegate这个类" class="headerlink" title="十、处理AppDelegate这个类"></a>十、处理<code>AppDelegate</code>这个类</h2><ul><li>在<code>AppDelegate.h</code>中做如下修改<br/><br> <img src="/images/20160830/Snip20160830_22.png" alt="处理`AppDelegate`这个类"><br/></li><li>在<code>AppDelegate.m</code>中做如下修改<br/><br>  <img src="/images/20160830/Snip20160830_23.png" alt="处理`AppDelegate`这个类"><br/>  ![处理`AppDelegate`这个类](/images/20160830/Snip20160830_24.png)<br/>  ![处理`AppDelegate`这个类](/images/20160830/Snip20160830_25.png)</li></ul>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> U3D </tag>
            
            <tag> Unity 3D </tag>
            
            <tag> Unity </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>搭建IPv6本地环境测试App</title>
      <link href="/posts/367808b.html"/>
      <url>/posts/367808b.html</url>
      
        <content type="html"><![CDATA[<h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>最近有很多人都在关注支持<code>IPv6</code>的事情，果然是苹果打个哈欠，<code>iOS</code>行业内就得起一次风暴呀。自从5月初<code>Apple</code>明文规定所有开发者在6月1号以后提交新版本必须需要支持<code>IPv6-Only</code>的网络。</p><h2 id="二、IPv6-Only支持是什么？"><a href="#二、IPv6-Only支持是什么？" class="headerlink" title="二、IPv6-Only支持是什么？"></a>二、<code>IPv6-Only</code>支持是什么？</h2><p><code>IPv6</code>是对<code>IPv4</code>地址空间的扩充，<code>IPv4</code>和<code>IPv6</code>的区别就是<code>IP</code>地址前者是<code>.</code>（<code>dot</code>）分割，后者是以<code>:</code>冒号）分割的（更多详细信息自行搜索）。<span id="more"></span><br>目前当我们的<code>iOS</code>设备连接上<code>WiFi</code>、<code>4G</code>、<code>3G</code>等网络时，设备被分配的地址均是<code>IPv4</code>，但是随着运营商和企业逐渐部署<code>IPv6 DNS64/NAT64</code>网络之后，设备被分配的地址会变成<code>IPv6</code>的地址，而这些网络就是所谓的<code>IPv6-Only</code>网络，并且仍然可以通过此网络去获取<code>IPv4</code>地址提供的内容。客户端向服务器端请求域名解析，首先通过<code>DNS64 Server</code>查询<code>IPv6</code>的地址，如果查询不到，再向<code>DNS Server</code>查询<code>IPv4</code>地址，通过<code>DNS64 Server</code>合成一个<code>IPv6</code>的地址，最终将一个<code>IPv6</code>的地址返回给客户端。</p><p>如图所示：</p><p><img src="/images/20160531/Snip20160531_0.png" alt="Snip20160531_0"></p><h2 id="三、搭建IPv6环境测试你的APP"><a href="#三、搭建IPv6环境测试你的APP" class="headerlink" title="三、搭建IPv6环境测试你的APP"></a>三、搭建<code>IPv6</code>环境测试你的<code>APP</code></h2><p>在<code>Mac OS 10.11＋</code>的双网卡的<code>Mac</code>机器（以太网口＋无线网卡），我们可以通过模拟构建这么一个<code>local IPv6 DNS64/NAT64</code>的网络环境去测试应用是否支持<code>IPv6-Only</code>网络，大概原理如下：</p><p><img src="/images/20160531/Snip20160531_1.png" alt="Snip20160531_1"></p><p>搭建<code>IPv6</code>测试环境说白了就是用<code>Mac</code>做一个热点，然后用<code>iPhone</code>连接这个<code>Wi-Fi</code>，听起来很容易，下面跟着我的步伐走吧。（非<code>WiFi</code>上网方式的<code>Mac</code>）<br>和正常的开启<code>Mac</code>热点的方式的区别是这次我们产生的是一个本地的<code>IPv6 DNS64/NAT64</code>网络，这项功能是<code>OS X 10.11</code>新加的功能（如果你的<code>Mac</code>系统版本不是的话必须要升级哦，才能产生<code>IPv6</code>的热点）。<br>和我们以前开启热点方式不一样的地方在于，我们在<code>系统偏好设置（System Preferences）</code>界面选中<code>共享（Sharing）</code>的同时，要按住<code>Option</code>键。见图：</p><h3 id="步骤一："><a href="#步骤一：" class="headerlink" title="步骤一："></a>步骤一：</h3><p><img src="/images/20160531/Snip20160531_2.png" alt="Snip20160531_2"></p><p>之后在<code>共享</code>界面中，我们会看到和之前不一样的地方，就是红框所标的地方，多了一个叫<code>创建 NAT64 网络</code> 的选框，选中它。</p><h3 id="步骤二："><a href="#步骤二：" class="headerlink" title="步骤二："></a>步骤二：</h3><p><img src="/images/20160531/Snip20160531_3.png" alt="Snip20160531_3"></p><p>接下来在<code>共享</code>窗口中，依次按图中所示的标号来，如图所示</p><h3 id="步骤三："><a href="#步骤三：" class="headerlink" title="步骤三："></a>步骤三：</h3><p><img src="/images/20160531/Snip20160531_4.png" alt="Snip20160531_4"></p><p>随后请点击<code>共享以下来源的连接</code>的下拉列表，选择我们想要共享出去的网络接口。我当前是想要共享的是<code>以太网</code>。</p><p><strong>PS：</strong>如果你的<code>Mac</code>是用有线拨号上网的话，请选择<code>PPOE</code>选项作为共享源。如果你的<code>Mac</code>是用有线上网（不用拨号的）的话，请选择<code>Thunderbolt 以太网有线网</code>选项作为共享源如果使用的是有线的<code>RJ-45</code>接头转<code>USB</code>输出的网络转换工具，请选<code>USB 10/100/1000 LAN</code>。</p><p><strong>标号1</strong></p><p><img src="/images/20160531/Snip20160531_5.png" alt="Snip20160531_5"></p><p><strong>标号2：</strong>用以下端口共享给电脑 选项此处选择<code>Wi-Fi</code></p><p><img src="/images/20160531/Snip20160531_6.png" alt="Snip20160531_6"></p><p><strong>标号3：</strong>点击<code>Wi-Fi选项...</code>选项，个性化自己的热点的设置</p><p><img src="/images/20160531/Snip20160531_7.png" alt="Snip20160531_7"></p><h3 id="步骤四："><a href="#步骤四：" class="headerlink" title="步骤四："></a>步骤四：</h3><p><img src="/images/20160531/Snip20160531_8.png" alt="Snip20160531_8"></p><h2 id="四、大功告成"><a href="#四、大功告成" class="headerlink" title="四、大功告成"></a>四、大功告成</h2><p>出现以下变化证明你已经成功产生了一个<code>IPv6</code>的热点</p><p><img src="/images/20160531/Snip20160531_9.png" alt="Snip20160531_9"></p><p><code>Wi-Fi</code>图标变样</p><p><img src="/images/20160531/Snip20160531_10.png" alt="Snip20160531_10"></p><p><strong>看手机的连接共享<code>Wi-Fi</code>的变化</strong><br><strong>普通热点共享</strong></p><p><img src="/images/20160531/Snip20160531_11.png" alt="Snip20160531_11"></p><p><strong><code>IPv6</code>热点共享</strong></p><p><img src="/images/20160531/Snip20160531_12.png" alt="Snip20160531_12"></p><p>对比2张图中<code>DNS</code>的地址看到区别了吧，一个<code>.</code>分割，一个<code>:</code>分割。</p><p>接下来就是测试你的<code>APP</code>是否可以在该WiFi下是否可以访问网络了</p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IPv6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Xcode 7.2 真机调试iOS 9.3的设备</title>
      <link href="/posts/eaae692a.html"/>
      <url>/posts/eaae692a.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>昨天回到家一不小心把测试机(没有设密码)升级到<code>9.3.1</code>了，立马悲剧了，<br>真机调试时报错：<code>Could not find Developer Disk Image </code>，<br>原因是：<code>Xcode7.2</code>中还没有支持<code>9.3</code>的<code>Disk Image</code>。</p><span id="more"></span><h2 id="iOS-9-3-Could-not-find-Developer-Disk-Image真机调试错误解决办法"><a href="#iOS-9-3-Could-not-find-Developer-Disk-Image真机调试错误解决办法" class="headerlink" title="iOS 9.3 -&gt; Could not find Developer Disk Image真机调试错误解决办法"></a><code>iOS 9.3</code> -&gt; <code>Could not find Developer Disk Image</code>真机调试错误解决办法</h2><ul><li><p>将<code>Xcode</code>更新到最新版本<code>7.3</code>，因为支持<code>iOS 9.3</code>的<code>Xcode</code>版本为 <code>7.3</code>（但是<code>Xcode 7.3</code>要求最小系统为<code>10.11</code>，所以这个对于系统还是<code>10.10</code>的没有用）。</p></li><li><p>下载该<code>Disk Image</code>，放到<code>/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/DeviceSupport</code><br>文件夹下，重启<code>Xcode</code>即可解决此类问题。</p></li></ul><h2 id="资源文件下载地址"><a href="#资源文件下载地址" class="headerlink" title="资源文件下载地址"></a>资源文件下载地址</h2><ul><li><p>对于<code>Xcode</code>老是在<code>App Store</code>升级失败，而且下载慢，我找到了这个－－&gt; 官方<code>Xcode.dmg</code>文件下载链接：<a href="http://stackoverflow.com/questions/10335747/how-to-download-xcode-4-5-6-7-and-get-the-dmg-file/10335943#10335943">超级传送门</a> </p></li><li><p><code>Disk Image 9.3</code> 下载地址：<a href="http://pan.baidu.com/s/1o7RwhlC">http://pan.baidu.com/s/1o7RwhlC</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 真机调试 </tag>
            
            <tag> Disk Image </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>编译.a静态库</title>
      <link href="/posts/b3b1bba4.html"/>
      <url>/posts/b3b1bba4.html</url>
      
        <content type="html"><![CDATA[<h1 id="一、编译-a静态库"><a href="#一、编译-a静态库" class="headerlink" title="一、编译.a静态库"></a>一、编译.a静态库</h1><h2 id="1-1-创建-a静态库"><a href="#1-1-创建-a静态库" class="headerlink" title="1.1 创建.a静态库"></a>1.1 创建.a静态库</h2><p>创建项目时,选择Framework&amp;Library–&gt;Static Library<br><img src="/images/20160321/E9EB6BD1-42BC-4DAA-B604-BC27104D7E83.png"></p><h2 id="1-2-编写核心代码"><a href="#1-2-编写核心代码" class="headerlink" title="1.2 编写核心代码"></a>1.2 编写核心代码</h2><p>TODO</p><p>编译静态库前,将头文件暴露出去<br><img src="/images/20160321/69A4E90A-09D5-4D7C-BAAC-4725B0B05490.png"></p><h2 id="1-3-编译模拟器和真机库"><a href="#1-3-编译模拟器和真机库" class="headerlink" title="1.3 编译模拟器和真机库"></a>1.3 编译模拟器和真机库</h2><p>打开Products即可看到.a静态库<br><img src="/images/20160321/1B41EE7F-F496-425D-9DD3-EF7D3D70DC53.png"></p><h2 id="1-4-测试使用静态库"><a href="#1-4-测试使用静态库" class="headerlink" title="1.4 测试使用静态库"></a>1.4 测试使用静态库</h2><p>创建一个项目,测试使用静态库即可.</p><h1 id="二、静态库的架构问题"><a href="#二、静态库的架构问题" class="headerlink" title="二、静态库的架构问题"></a>二、静态库的架构问题</h1><ul><li>设备的CPU架构<ul><li>不同的设备使用的CPU是不同的</li><li>CPU的不同造成使用的CPU架构(指令集)不同</li></ul></li><li>静态库有其支持的CPU架构<ul><li>如果静态库在不支持的CPU架构上运行就会报错</li></ul></li><li>模拟器使用的CPU架构<ul><li>iPhone4s-iPhone5 : i386</li><li>iPhone5s-iPhone6plus : x86_64</li></ul></li><li>真机使用的CPU架构<ul><li>iPhone3gs-iPhone4s : armv7</li><li>iPhone5-iPhone5c : armv7s</li><li>iPhone5s-iPhone6plus : arm64</li><li>唯一特殊:只要支持armv7的静态库可以在armv7s上正常运行</li></ul></li><li>查看静态库支持的架构<ul><li>lipo -info 静态库</li></ul></li><li>合并静态库<ul><li>lipo -create 静态库1 静态库2 -output 合并的静态库</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 静态库 </tag>
            
            <tag> .a </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>编译.framework静态库和调试静态库</title>
      <link href="/posts/1a1c1826.html"/>
      <url>/posts/1a1c1826.html</url>
      
        <content type="html"><![CDATA[<p>#一、编译.framework静态库</p><h2 id="1-1-创建项目时-选择Framework-Library–-Frameword"><a href="#1-1-创建项目时-选择Framework-Library–-Frameword" class="headerlink" title="1.1 创建项目时,选择Framework&amp;Library–&gt;Frameword"></a>1.1 创建项目时,选择Framework&amp;Library–&gt;Frameword</h2><p><img src="/images/20160321/6C01F5C3-C5FC-44F2-9267-223FC9B33A14.png"></p><p>默认创建的项目中有一个主头文件,可以将其他头文件在该头文件中<code>import </code>一下</p><p><img src="/images/20160321/D859482D-0C54-4D1C-BB46-9E6F122B47A3.png"></p><h2 id="1-2-编写核心代码"><a href="#1-2-编写核心代码" class="headerlink" title="1.2 编写核心代码"></a>1.2 编写核心代码</h2><p>编译库前,将头文件暴露出去<br><img src="/images/20160321/3FE05F17-AAEE-46EE-BB97-AE404254461D.png"></p><p>默认情况直接编译的库位动态库,可以修改配置改成静态库</p><p><img src="/images/20160321/92452F61-41EE-467E-8CCA-0B237AD92C8C.png"></p><h2 id="1-3-分别编译模拟器和真机库"><a href="#1-3-分别编译模拟器和真机库" class="headerlink" title="1.3 分别编译模拟器和真机库"></a>1.3 分别编译模拟器和真机库</h2><p>打开Products即可看到.framework库</p><p><img src="/images/20160321/E8F189C3-97FA-4BA6-8FDB-C2F764E91030.png"></p><h1 id="二、开发调试静态库"><a href="#二、开发调试静态库" class="headerlink" title="二、开发调试静态库"></a>二、开发调试静态库</h1><p>如果希望一遍开发一遍调试静态库,可以在项目中直接添加静态库</p><p>在项目中，按照下面步骤即可：</p><ul><li>点击项目–&gt;左下角+号<br><img src="/images/20160321/15A256D7-04AA-4341-B6ED-95FEDBE4AAF8.png"></li><li>选择希望开发的静态库类型(.a&#x2F;.framework)<br><img src="/images/20160321/C9DF0D82-57DC-44DA-96B3-21E6DD89AD5F.png"></li><li>创建静态库后,即可看到静态库文件<br><img src="/images/20160321/C43F6E17-9CC6-4FE7-912D-DBC956372122.png"></li></ul><h2 id="使用静态库"><a href="#使用静态库" class="headerlink" title="使用静态库"></a>使用静态库</h2><ul><li>使用静态库前需要进行配置<br><img src="/images/20160321/26D71492-916D-4EED-9598-5F6F8935BC9D.png"></li><li>测试之后,按照之前步骤打包成静态库即可</li></ul><h2 id="静态库合并"><a href="#静态库合并" class="headerlink" title="静态库合并"></a>静态库合并</h2><p>根据编译选择的机器类型，静态库有模拟器和真机的区别，两者是不能混用的。<br>此时可以通过配置一个Run Script，在Script中使用lipo命令来合并两个版本的Framework，重新生成一个新的Framework，这个Framework将同时支持在模拟器和真机上运行。</p><p>在项目的Build Phases中，新建一个Run Script，输入下面内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">if [ &quot;$&#123;ACTION&#125;&quot; = &quot;build&quot; ]</span><br><span class="line">then</span><br><span class="line">INSTALL_DIR=$&#123;SRCROOT&#125;/Products/$&#123;PROJECT_NAME&#125;.framework</span><br><span class="line"></span><br><span class="line">DEVICE_DIR=$&#123;BUILD_ROOT&#125;/$&#123;CONFIGURATION&#125;-iphoneos/$&#123;PROJECT_NAME&#125;.framework</span><br><span class="line"></span><br><span class="line">SIMULATOR_DIR=$&#123;BUILD_ROOT&#125;/$&#123;CONFIGURATION&#125;-iphonesimulator/$&#123;PROJECT_NAME&#125;.framework</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if [ -d &quot;$&#123;INSTALL_DIR&#125;&quot; ]</span><br><span class="line">then</span><br><span class="line">rm -rf &quot;$&#123;INSTALL_DIR&#125;&quot;</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">mkdir -p &quot;$&#123;INSTALL_DIR&#125;&quot;</span><br><span class="line"></span><br><span class="line">cp -R &quot;$&#123;DEVICE_DIR&#125;/&quot; &quot;$&#123;INSTALL_DIR&#125;/&quot;</span><br><span class="line">#ditto &quot;$&#123;DEVICE_DIR&#125;/Headers&quot; &quot;$&#123;INSTALL_DIR&#125;/Headers&quot;</span><br><span class="line"></span><br><span class="line">lipo -create &quot;$&#123;DEVICE_DIR&#125;/$&#123;PROJECT_NAME&#125;&quot; &quot;$&#123;SIMULATOR_DIR&#125;/$&#123;PROJECT_NAME&#125;&quot; -output &quot;$&#123;INSTALL_DIR&#125;/$&#123;PROJECT_NAME&#125;&quot;</span><br><span class="line"></span><br><span class="line">#open &quot;$&#123;DEVICE_DIR&#125;&quot;</span><br><span class="line">#open &quot;$&#123;SRCROOT&#125;/Products&quot;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><p>当项目再次Build时，就会在项目目录下面出现Products目录，里面包含了合并后的Framework文件夹。</p><p>使用lipo -info来检测下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lipo -info 二进制文件路径(拖进来即可)</span><br></pre></td></tr></table></figure><p>如果出现：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x86_64 armv7 arm64</span><br></pre></td></tr></table></figure><p>说明成功合并架构</p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 静态库 </tag>
            
            <tag> framework </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iOS App上传项目遇到的问题</title>
      <link href="/posts/a732f390.html"/>
      <url>/posts/a732f390.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-提示iTunes-Store-operation-filed（Cannot-verify-client）"><a href="#1-提示iTunes-Store-operation-filed（Cannot-verify-client）" class="headerlink" title="1. 提示iTunes Store operation filed（Cannot verify client）"></a>1. 提示<code>iTunes Store operation filed（Cannot verify client）</code></h2><p><img src="/images/20160316/Snip20160316_0.png" alt="Snip20160316_0.png"></p><p><strong>错误原因：</strong>没有验证到<code>Itunes Store</code>，网速过慢导致，或者网络堵塞<br><strong>解决办法：</strong>找个网络快的地方再试试吧！！</p><hr><span id="more"></span><h2 id="2-在上传项目的时候，UpLoad-App-Store后弹出iTunes-Store-operation-failed"><a href="#2-在上传项目的时候，UpLoad-App-Store后弹出iTunes-Store-operation-failed" class="headerlink" title="2. 在上传项目的时候，UpLoad App Store后弹出iTunes Store operation failed"></a>2. 在上传项目的时候，<code>UpLoad App Store</code>后弹出<code>iTunes Store operation failed</code></h2><p><img src="/images/20160316/Snip20160316_1.png" alt="Snip20160316_1"></p><p><strong>错误原因：</strong>你在<code>Itunes Connect</code>（<a href="https://itunesconnect.apple.com/">https://itunesconnect.apple.com</a>）网站里没有对应你<code>Xcode</code>项目设置的这个<code>Bundle Id</code>的应用<br><strong>解决办法：</strong>去<a href="https://itunesconnect.apple.com/">https://itunesconnect.apple.com</a>添加这个应用</p><hr><h2 id="3-这个问题比较麻烦，多半是证书，描述文件Bundle-ID不匹配原因！"><a href="#3-这个问题比较麻烦，多半是证书，描述文件Bundle-ID不匹配原因！" class="headerlink" title="3. 这个问题比较麻烦，多半是证书，描述文件Bundle ID不匹配原因！"></a>3. 这个问题比较麻烦，多半是证书，描述文件<code>Bundle ID</code>不匹配原因！</h2><p><img src="/images/20160316/Snip20160316_2.png" alt="Snip20160316_2"></p><p><strong>错误原因：</strong>证书和描述文件不匹配。也就是你选择描述文件（而描述文件绑定的证书不是你机器上的证书）<br><strong>解决办法：</strong>让证书自动去寻找描述文件。看下图</p><p><img src="/images/20160316/Snip20160316_3.png" alt="Snip20160316_3"></p><p><img src="/images/20160316/Snip20160316_4.png" alt="Snip20160316_4"></p><p>如果还不行，就确认下你的证书和描述文件 是否真正对应上了!</p><hr><h2 id="4-Itunes-Store-operation-failed"><a href="#4-Itunes-Store-operation-failed" class="headerlink" title="4. Itunes Store operation failed"></a>4. <code>Itunes Store operation failed</code></h2><p><img src="/images/20160316/Snip20160316_5.png" alt="Snip20160316_5"></p><p><strong>解决方法：</strong>重新启动<code>Xcode</code>完全退出。</p><hr><h2 id="5-Archive是灰色的，不能选择"><a href="#5-Archive是灰色的，不能选择" class="headerlink" title="5. Archive是灰色的，不能选择"></a>5. <code>Archive</code>是灰色的，不能选择</h2><p><img src="/images/20160316/Snip20160316_6.png" alt="Snip20160316_6"></p><hr><h2 id="6-错误：二进制文件无效（构建版本无效）的问题"><a href="#6-错误：二进制文件无效（构建版本无效）的问题" class="headerlink" title="6. 错误：二进制文件无效（构建版本无效）的问题"></a>6. 错误：二进制文件无效（构建版本无效）的问题</h2><p><img src="/images/20160316/Snip20160316_7.png" alt="Snip20160316_7"></p><p><strong>错误原因：</strong>可能是你工程里有问题。<br><strong>解决办法：</strong>看看你当初注册申请的<code>App ID</code>绑定的邮箱，因为你这个构建版本有问题的时候，苹果公司会给你发个邮件（里面会详细说明你的问题）不过<code>百分之50</code>都是百度地图的问题 需要在这里添加<code>-ObjC</code>要注意大小写</p><p><img src="/images/20160316/Snip20160316_8.png" alt="Snip20160316_8"></p><p><em><strong><code>-Objc</code>作用是：</strong></em>加了这个参数后，链接器就会把静态库中所有的<code>Objective-C</code>类和分类都加载到最后的可执行文件中。</p><hr><h2 id="7-用Xcode直接上传App-Store出现如下图错误：（之前是用Xcode6-4上传的，提交了n次都报这个错）"><a href="#7-用Xcode直接上传App-Store出现如下图错误：（之前是用Xcode6-4上传的，提交了n次都报这个错）" class="headerlink" title="7. 用Xcode直接上传App Store出现如下图错误：（之前是用Xcode6.4上传的，提交了n次都报这个错）"></a>7. 用<code>Xcode</code>直接上传<code>App Store</code>出现如下图错误：（之前是用<code>Xcode6.4</code>上传的，提交了<code>n</code>次都报这个错）</h2><p><img src="/images/20160316/Snip20160316_9.png" alt="Snip20160316_9"></p><p><strong>解决办法：</strong>用<code>Xcode7</code>上传就不会包这个错误了，所以大家遇到这个问题，直接用<code>Xcode7</code>以上的版本提交。</p><hr><h2 id="8-上传iTunes报下面错误"><a href="#8-上传iTunes报下面错误" class="headerlink" title="8. 上传iTunes报下面错误"></a>8. 上传<code>iTunes</code>报下面错误</h2><p><img src="/images/20160316/Snip20160316_10.png" alt="Snip20160316_10"></p><p><strong>解决办法：</strong></p><p><img src="/images/20160316/Snip20160316_11.png" alt="Snip20160316_11"></p><hr><h2 id="9-打包时遇见的错误–App配置为iOS路由App"><a href="#9-打包时遇见的错误–App配置为iOS路由App" class="headerlink" title="9. 打包时遇见的错误–App配置为iOS路由App"></a>9. 打包时遇见的错误–<code>App</code>配置为<code>iOS</code>路由<code>App</code></h2><p>要将<code>App</code>配置为<code>iOS</code>路由<code>App</code>，请在<code>iTunes Connect</code>的我的<code>App</code>中的<code>App</code>版本页面上传<code>App</code>地区范围文件 </p><p><strong>解决办法：</strong></p><p><img src="/images/20160316/Snip20160316_12.png" alt="Snip20160316_12"></p><p>把<code>Map</code>关掉!</p><hr><h2 id="10-iOS此证书的签发者无效"><a href="#10-iOS此证书的签发者无效" class="headerlink" title="10. iOS此证书的签发者无效"></a>10. <code>iOS</code>此证书的签发者无效</h2><p>上传<code>App</code>报错,如图: </p><p><img src="/images/20160316/Snip20160316_13.png" alt="Snip20160316_13"></p><p><strong>解决办法：</strong></p><ol><li>下载<br><a href="http://demo.netfoucs.com/qxuewei/article/details/50704824#">https://developer.apple.com/certificationauthority/AppleWWDRCA.cer</a><br>的证书，然后双击安装。</li><li>在钥匙串里选择登录,然后点选证书，在这个界面，选择工具栏的<code>View</code> -&gt;显示过期证书(<code>Show Expired Certificates</code>)，这时候你会发现一个过期的(<code>Apple Worldwide Developer Relations Certification Authority</code>），删除它。</li><li>在系统(System)的那一栏也有这个过期的<code>WWDR Certificate</code>，一并删除它。</li><li>不出意外你的证书那里从<code>This certificate has an invalid issuer</code>（此证书的签发者无效）变成了<code>This certificate is valid</code>了。</li></ol><hr><h2 id="11-上传时遇到以下错误"><a href="#11-上传时遇到以下错误" class="headerlink" title="11. 上传时遇到以下错误"></a>11. 上传时遇到以下错误</h2><p><img src="/images/20160316/Snip20160316_14.png" alt="Snip20160316_14"></p><p><strong>解决方法：</strong></p><p>很简单<code>Xcode</code> -&gt; <code>Product</code> -&gt; <code>Clean</code>，然后重新打包！</p><hr><h2 id="12-将App上传到App-Store的时候通常会遇到这个问题"><a href="#12-将App上传到App-Store的时候通常会遇到这个问题" class="headerlink" title="12. 将App上传到App Store的时候通常会遇到这个问题"></a>12. 将<code>App</code>上传到<code>App Store</code>的时候通常会遇到这个问题</h2><p><img src="/images/20160316/Snip20160316_15.png" alt="Snip20160316_15"></p><p><strong>解决方法：</strong></p><p>很多人说苹果那边服务器问题，重复尝试几次，总会成功的！<br>不过我还是推荐用<code>Application Loader</code>上传，成功率就非常高。<br>如果<code>Application Loader</code>也不行，需要检查下自己的网络，有时候<code>VPN</code>也会提高速度（不行就等一段时间试试）。</p><p>其他<a href="http://blog.csdn.net/ws1352864983/article/details/52314776"> iOS Xcode 打包IPA问题集锦  </a></p><p>###还有什么问题？欢迎大家补充…</p><ul><li>以上部分有转载网络其它文章，如果原作者有意见，可以联系我删除。</li></ul>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AppStore </tag>
            
            <tag> App上传 </tag>
            
            <tag> UpLoad </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iOS App上架流程（2016详细版）</title>
      <link href="/posts/62c91431.html"/>
      <url>/posts/62c91431.html</url>
      
        <content type="html"><![CDATA[<h2 id="一、前言："><a href="#一、前言：" class="headerlink" title="一、前言："></a>一、前言：</h2><p>作为一名<code>iOSer</code>，把开发出来的<code>App</code>上传到<code>App Store</code>是必要的。下面就来详细讲解一下具体流程步骤。</p><h2 id="二、准备："><a href="#二、准备：" class="headerlink" title="二、准备："></a>二、准备：</h2><ol><li>一个已付费的开发者账号（账号类型分为个人（<code>Individual</code>）、公司（<code>Company</code>）、企业（<code>Enterprise</code>）、高校（<code>University</code>）四种类型，每年资费分别为<code>$99</code>、<code>$99</code>、<code>$299</code>、<code>免费</code>。）。</li><li>一个已经开发完成的项目。</li></ol><span id="more"></span><h2 id="三、检查："><a href="#三、检查：" class="headerlink" title="三、检查："></a>三、检查：</h2><ol><li>你的<code>Xcode</code>必须是正式版的，<code>beta</code>版本的<code>Xcode</code>是不能上传项目的。</li><li>上传使用的<code>Mac</code>的<code>OS X</code>系统必须也是正式版的，<code>beta</code>版本也不行。</li><li>请确认你安装的<code>Xcode</code>是从<code>App Store</code>或者是开发者网站下载的，而不是从其它渠道获取的安装包安装的,因为非官方途径下载的<code>Xcode</code>可能带有<code>XcodeGhost</code>病毒。如何检查？</li></ol><p><img src="/images/20160315/Snip20160315_0.png" alt="检查方法"></p><h2 id="四、生成发布证书"><a href="#四、生成发布证书" class="headerlink" title="四、生成发布证书"></a>四、生成发布证书</h2><h3 id="1-打开苹果开发者中心：https-developer-apple-com"><a href="#1-打开苹果开发者中心：https-developer-apple-com" class="headerlink" title="1. 打开苹果开发者中心：https://developer.apple.com"></a>1. 打开苹果开发者中心：<a href="https://developer.apple.com/">https://developer.apple.com</a></h3><p>打开后点击：<code>Account</code></p><p><img src="/images/20160315/Snip20160315_1.png" alt="苹果开发者中心"></p><p>下面输入已付款过的<code>Apple</code>账号和密码登录（如果你的电脑已经保存了密码，会直接进入）</p><p><img src="/images/20160315/Snip20160315_2.png" alt="开发者登录账号"></p><h3 id="2-点击：Certificates-Identifiers-Profiles-专门生成证书，绑定Bundle-Id，绑定device设备，生成描述文件的地方"><a href="#2-点击：Certificates-Identifiers-Profiles-专门生成证书，绑定Bundle-Id，绑定device设备，生成描述文件的地方" class="headerlink" title="2. 点击：Certificates, Identifiers &amp; Profiles (专门生成证书，绑定Bundle Id，绑定device设备，生成描述文件的地方)"></a>2. 点击：<code>Certificates</code>, <code>Identifiers &amp; Profiles</code> (专门生成证书，绑定<code>Bundle Id</code>，绑定<code>device</code>设备，生成描述文件的地方)</h3><p><img src="/images/20160315/Snip20160315_3.png" alt="Member Center"></p><h3 id="3-点击Certificates生成证书"><a href="#3-点击Certificates生成证书" class="headerlink" title="3. 点击Certificates生成证书"></a>3. 点击<code>Certificates</code>生成证书</h3><ol><li>选择<code>iOS, tvOS, watchOS</code></li><li>选择<code>All</code></li><li>点击右上角新添加证书</li></ol><p><img src="/images/20160315/Snip20160315_4.png" alt="添加新证书1"></p><h3 id="4-由于是做App上传，选择生产证书（选择App-Store-and-Ad-Hoc）"><a href="#4-由于是做App上传，选择生产证书（选择App-Store-and-Ad-Hoc）" class="headerlink" title="4. 由于是做App上传，选择生产证书（选择App Store and Ad Hoc）"></a>4. 由于是做<code>App</code>上传，选择生产证书（选择<code>App Store and Ad Hoc</code>）</h3><p><img src="/images/20160315/Snip20160315_5.png" alt="选择App Store and Ad Hoc"></p><p><strong>注意：</strong> 一个开发者账号只能创建（1-2个开发（测试）证书，2-3个生产（发布）证书），如果你的<code>App Store Ad Hoc</code>前面的按钮不能选择，则代表你的这个账号无法再创建新的生产证书了。</p><p>解决方法：</p><ol><li>从共同使用这个账号的人电脑上生成.p12文件，导入自己的电脑。（尽量不要执行下面第2步）</li><li>如果你想生成的话，把现有的删除一个（建议删除时间比较靠前的）。注意：如果删除一个证书，那么正在使用这个证书的人将不能再使用了，除非重新生成，然后利用.p12重新导入自己的电脑里！</li></ol><p><em><strong>注意：</strong></em>如果你想删除证书，执行下面步骤，否则略过。</p><p><img src="/images/20160315/Snip20160315_6.png" alt="删除证书"></p><p>然后接上上图，生产证书部分继续</p><p><img src="/images/20160315/Snip20160315_7.png" alt="生成证书2"></p><p><img src="/images/20160315/Snip20160315_8.png" alt="生成证书3"></p><p><img src="/images/20160315/Snip20160315_9.png" alt="生成证书4"></p><h3 id="5-上传CSR文件去获取证书（CSR文件需要我们到本机钥匙串里去创建）"><a href="#5-上传CSR文件去获取证书（CSR文件需要我们到本机钥匙串里去创建）" class="headerlink" title="5. 上传CSR文件去获取证书（CSR文件需要我们到本机钥匙串里去创建）"></a>5. 上传<code>CSR</code>文件去获取证书（CSR文件需要我们到本机钥匙串里去创建）</h3><h4 id="1-在Launchpad的其他里面，点击钥匙串访问弹出如下界面"><a href="#1-在Launchpad的其他里面，点击钥匙串访问弹出如下界面" class="headerlink" title="1. 在Launchpad的其他里面，点击钥匙串访问弹出如下界面"></a>1. 在<code>Launchpad</code>的<strong>其他</strong>里面，点击<strong>钥匙串访问</strong>弹出如下界面</h4><p><img src="/images/20160315/Snip20160315_10.png" alt="其他"></p><p><img src="/images/20160315/Snip20160315_11.png" alt="钥匙串访问"></p><h4 id="2-工具栏选择钥匙串访问-证书助理-从证书颁发机构请求证书…"><a href="#2-工具栏选择钥匙串访问-证书助理-从证书颁发机构请求证书…" class="headerlink" title="2. 工具栏选择钥匙串访问-&gt;证书助理-&gt;从证书颁发机构请求证书…"></a>2. 工具栏选择<strong>钥匙串访问</strong>-&gt;<strong>证书助理</strong>-&gt;<strong>从证书颁发机构请求证书…</strong></h4><p><img src="/images/20160315/Snip20160315_12.png" alt="请求证书"></p><p><img src="/images/20160315/Snip20160315_13.png" alt="证书信息"></p><h4 id="3-将CSR文件保存到MAC磁盘的某个位置（这里我选择的是桌面，进行存储）"><a href="#3-将CSR文件保存到MAC磁盘的某个位置（这里我选择的是桌面，进行存储）" class="headerlink" title="3. 将CSR文件保存到MAC磁盘的某个位置（这里我选择的是桌面，进行存储）"></a>3. 将<code>CSR</code>文件保存到<code>MAC</code>磁盘的某个位置（这里我选择的是桌面，进行存储）</h4><p><img src="/images/20160315/Snip20160315_14.png" alt="存储证书"></p><p><img src="/images/20160315/Snip20160315_15.png" alt="点击完成"></p><p><img src="/images/20160315/Snip20160315_16.png" alt="CertificateSigningRequest.certSigningRequest 文件"></p><h3 id="6-然后回到浏览器，点击Choose-File"><a href="#6-然后回到浏览器，点击Choose-File" class="headerlink" title="6. 然后回到浏览器，点击Choose File... "></a>6. 然后回到浏览器，点击<code>Choose File... </code></h3><p><img src="/images/20160315/Snip20160315_17.png" alt="选择CSR文件"></p><h3 id="7-选择创建好的：CertificateSigningRequest-certSigningRequest文件，点击选取"><a href="#7-选择创建好的：CertificateSigningRequest-certSigningRequest文件，点击选取" class="headerlink" title="7. 选择创建好的：CertificateSigningRequest.certSigningRequest文件，点击选取"></a>7. 选择创建好的：<code>CertificateSigningRequest.certSigningRequest</code>文件，点击<strong>选取</strong></h3><p><img src="/images/20160315/Snip20160315_18.png" alt="选取CSR文件"></p><p>点击<code>Generate</code>上传证书</p><p><img src="/images/20160315/Snip20160315_19.png" alt="上传CSR证书"></p><h3 id="8-跳转到如下界面，点击-DownLoad-下载生成的证书（cer后缀的文件），然后点击Done，你创建的发布证书就会存储在帐号中。"><a href="#8-跳转到如下界面，点击-DownLoad-下载生成的证书（cer后缀的文件），然后点击Done，你创建的发布证书就会存储在帐号中。" class="headerlink" title="8. 跳转到如下界面，点击 DownLoad 下载生成的证书（cer后缀的文件），然后点击Done，你创建的发布证书就会存储在帐号中。"></a>8. 跳转到如下界面，点击 <strong>DownLoad</strong> 下载生成的证书（<code>cer</code>后缀的文件），然后点击<code>Done</code>，你创建的发布证书就会存储在帐号中。</h3><p><img src="/images/20160315/Snip20160315_20.png" alt="下载生成的证书"></p><p><img src="/images/20160315/Snip20160315_21.png" alt="cer后缀的文件"></p><p><strong>注意：</strong>这个证书只能下载一次。点击下载后，关闭页面后就不能再回到下载页面了。<br>如果不需要给别的电脑使用，则直接跳过下面<strong>附加项</strong>，跳转到<strong>第五步</strong>（绑定<code>Bundle Identifier</code>）</p><h3 id="附加项：生成p12文件在其他电脑上使用这个发布证书"><a href="#附加项：生成p12文件在其他电脑上使用这个发布证书" class="headerlink" title="附加项：生成p12文件在其他电脑上使用这个发布证书"></a>附加项：生成<code>p12</code>文件在其他电脑上使用这个发布证书</h3><h4 id="1-双击安装证书后，打开钥匙串访问，选择安装的证书右键单击"><a href="#1-双击安装证书后，打开钥匙串访问，选择安装的证书右键单击" class="headerlink" title="1. 双击安装证书后，打开钥匙串访问，选择安装的证书右键单击"></a>1. 双击安装证书后，打开钥匙串访问，选择安装的证书右键单击</h4><p><img src="/images/20160315/Snip20160315_22.png" alt="安装的发布证书"></p><p><strong>注意：</strong>如果没有<em><strong>导出</strong></em>，可以把这个证书删除，然后重新双击下载的证书文件安装。</p><h4 id="2-导出证书"><a href="#2-导出证书" class="headerlink" title="2. 导出证书"></a>2. 导出证书</h4><p><img src="/images/20160315/Snip20160315_23.png" alt="导出证书"></p><h4 id="3-存储证书"><a href="#3-存储证书" class="headerlink" title="3. 存储证书"></a>3. 存储证书</h4><p><img src="/images/20160315/Snip20160315_24.png" alt="存储导出的证书"></p><p><strong>注意：</strong>存储的文件格式一定要是<code>.p12</code></p><h4 id="4-设置密码"><a href="#4-设置密码" class="headerlink" title="4. 设置密码"></a>4. 设置密码</h4><p>可以为证书设置密码，也可以不设置密码；如果设置了密码，那么别人安装这个证书的时候就要输入密码，否则无法安装。这里就不设置密码了。</p><p><img src="/images/20160315/Snip20160315_25.png" alt="设置密码"></p><h4 id="5-保存导出的证书"><a href="#5-保存导出的证书" class="headerlink" title="5. 保存导出的证书"></a>5. 保存导出的证书</h4><p><img src="/images/20160315/Snip20160315_26.png" alt="p12发布证书"></p><p>如果需要在其它电脑上也能发布App,那么就必须要安装这个发布证书。</p><h2 id="五、创建App-IDs和绑定你的App的Bundle-Identifier"><a href="#五、创建App-IDs和绑定你的App的Bundle-Identifier" class="headerlink" title="五、创建App IDs和绑定你的App的Bundle Identifier"></a>五、创建<code>App IDs</code>和绑定你的<code>App</code>的<code>Bundle Identifier</code></h2><p>回到刚才的页面：<a href="https://developer.apple.com/account/ios/identifiers/bundle/bundleList.action">https://developer.apple.com/account/ios/identifiers/bundle/bundleList.action</a></p><h3 id="1-点击App-IDs-进入如下界面，点击右上角的-号"><a href="#1-点击App-IDs-进入如下界面，点击右上角的-号" class="headerlink" title="1. 点击App IDs,进入如下界面，点击右上角的 + 号"></a>1. 点击<code>App IDs</code>,进入如下界面，点击右上角的 <strong>+</strong> 号</h3><p><img src="/images/20160315/Snip20160315_27.png" alt="点击App IDs"></p><h3 id="2-填写App-IDs和Bundle-Identifier"><a href="#2-填写App-IDs和Bundle-Identifier" class="headerlink" title="2. 填写App IDs和Bundle Identifier"></a>2. 填写<code>App IDs</code>和<code>Bundle Identifier</code></h3><p><img src="/images/20160315/Snip20160315_28.png" alt="填写App IDs和Bundle Identifier"></p><p><strong>注意：</strong></p><ol><li>上传<code>App</code>使用的<code>Bundle Identifier</code>(不要有<code>-</code>，都是英文<code>+</code>数字)必须是固定的，不能使用占位符。</li><li>如果你的<code>Bundle Identifier</code>已经在网站上绑定了，如果你又修改了你工程里面这个<code>Bundle Identifier</code>的话，需要重新进入到开发者账号里面绑定。</li></ol><p><img src="/images/20160315/Snip20160315_29.png" alt="修改工程的Bundle Identifier"></p><p>下面选择<code>App</code>中包含的服务，默认有两项，其余的根据自己项目的需求进行选择</p><p><img src="/images/20160315/Snip20160315_30.png" alt="App Services"></p><h3 id="3-点击Continue"><a href="#3-点击Continue" class="headerlink" title="3. 点击Continue"></a>3. 点击<code>Continue</code></h3><p><img src="/images/20160315/Snip20160315_31.png" alt="点击continue"></p><h3 id="4-点击Register"><a href="#4-点击Register" class="headerlink" title="4. 点击Register"></a>4. 点击<code>Register</code></h3><p><img src="/images/20160315/Snip20160315_32.png" alt="点击Register"></p><h3 id="5-点击Done"><a href="#5-点击Done" class="headerlink" title="5. 点击Done"></a>5. 点击<code>Done</code></h3><p><img src="/images/20160315/Snip20160315_33.png" alt="点击Done"></p><h2 id="六、生成描述文件（描述文件的作用就是把证书和Bundle-Identifier关联起来）"><a href="#六、生成描述文件（描述文件的作用就是把证书和Bundle-Identifier关联起来）" class="headerlink" title="六、生成描述文件（描述文件的作用就是把证书和Bundle Identifier关联起来）"></a>六、生成描述文件（描述文件的作用就是把证书和<code>Bundle Identifier</code>关联起来）</h2><h3 id="1-找到Provisioning-Profiles-，点击All，然后点击右上角-号"><a href="#1-找到Provisioning-Profiles-，点击All，然后点击右上角-号" class="headerlink" title="1. 找到Provisioning Profiles ，点击All，然后点击右上角 + 号"></a>1. 找到<code>Provisioning Profiles</code> ，点击<code>All</code>，然后点击右上角 <code>+</code> 号</h3><p><img src="/images/20160315/Snip20160315_34.png" alt="Provisioning Profiles"></p><h3 id="2-因为是发布，所以选择下面App-Store这个描述文件，点击Continue"><a href="#2-因为是发布，所以选择下面App-Store这个描述文件，点击Continue" class="headerlink" title="2. 因为是发布，所以选择下面App Store这个描述文件，点击Continue"></a>2. 因为是发布，所以选择下面<code>App Store</code>这个描述文件，点击<code>Continue</code></h3><p><img src="/images/20160315/Snip20160315_35.png" alt="选择App Store"></p><h3 id="3-在App-ID这个选项栏里面找到你刚刚创建的：App-IDs（Bundle-Identifier）类型的套装，点击Continue"><a href="#3-在App-ID这个选项栏里面找到你刚刚创建的：App-IDs（Bundle-Identifier）类型的套装，点击Continue" class="headerlink" title="3. 在App ID这个选项栏里面找到你刚刚创建的：App IDs（Bundle Identifier）类型的套装，点击Continue"></a>3. 在<code>App ID</code>这个选项栏里面找到你刚刚创建的：<code>App IDs</code>（<code>Bundle Identifier</code>）类型的套装，点击<code>Continue</code></h3><p><img src="/images/20160315/Snip20160315_36.png" alt="选择发布项目的Bundle Identifier"></p><h3 id="4-选择你刚创建的发布证书（或者生成p12文件的那个发布证书），根据自己电脑上的发布证书日期来选择，点击Continue"><a href="#4-选择你刚创建的发布证书（或者生成p12文件的那个发布证书），根据自己电脑上的发布证书日期来选择，点击Continue" class="headerlink" title="4. 选择你刚创建的发布证书（或者生成p12文件的那个发布证书），根据自己电脑上的发布证书日期来选择，点击Continue"></a>4. 选择你刚创建的发布证书（或者生成<code>p12</code>文件的那个发布证书），根据自己电脑上的发布证书日期来选择，点击<code>Continue</code></h3><p><img src="/images/20160315/Snip20160315_37.png" alt="选择创建的发布证书"></p><h3 id="5-在Profile-Name栏里输入一个名字（这个是Provisioning-Profiles文件的名字，可随便输入，在这里我用工程名字，便于分别），然后点击Generate"><a href="#5-在Profile-Name栏里输入一个名字（这个是Provisioning-Profiles文件的名字，可随便输入，在这里我用工程名字，便于分别），然后点击Generate" class="headerlink" title="5. 在Profile Name栏里输入一个名字（这个是Provisioning Profiles文件的名字，可随便输入，在这里我用工程名字，便于分别），然后点击Generate"></a>5. 在<code>Profile Name</code>栏里输入一个名字（这个是<code>Provisioning Profiles</code>文件的名字，可随便输入，在这里我用工程名字，便于分别），然后点击<code>Generate</code></h3><p><img src="/images/20160315/Snip20160315_38.png" alt="给描述文件起个名字"></p><h3 id="6-Download生成的Provisioning-Profiles文件，然后点击Done，双击安装（闪一下就完事了，没其它效果）"><a href="#6-Download生成的Provisioning-Profiles文件，然后点击Done，双击安装（闪一下就完事了，没其它效果）" class="headerlink" title="6. Download生成的Provisioning Profiles文件，然后点击Done，双击安装（闪一下就完事了，没其它效果）"></a>6. <code>Download</code>生成的<code>Provisioning Profiles</code>文件，然后点击<code>Done</code>，双击安装（闪一下就完事了，没其它效果）</h3><p><img src="/images/20160315/Snip20160315_39.png" alt="Download生成的PP文件"></p><p><img src="/images/20160315/Snip20160315_40.png" alt="生成的描述文件"></p><h2 id="六、在App-Store开辟空间"><a href="#六、在App-Store开辟空间" class="headerlink" title="六、在App Store开辟空间"></a>六、在<code>App Store</code>开辟空间</h2><h3 id="1-回到Member-Center，点击iTunes-Connect"><a href="#1-回到Member-Center，点击iTunes-Connect" class="headerlink" title="1. 回到Member Center，点击iTunes Connect"></a>1. 回到<code>Member Center</code>，点击<code>iTunes Connect</code></h3><p><img src="/images/20160315/Snip20160315_41.png" alt="点击iTunes Connect"></p><h3 id="2-登录开发者账号（还是之前已付费的账号）"><a href="#2-登录开发者账号（还是之前已付费的账号）" class="headerlink" title="2. 登录开发者账号（还是之前已付费的账号）"></a>2. 登录开发者账号（还是之前已付费的账号）</h3><p><img src="/images/20160315/Snip20160315_42.png" alt="Snip20160315_68.png"></p><h3 id="3-登录成功后，点击我的App"><a href="#3-登录成功后，点击我的App" class="headerlink" title="3. 登录成功后，点击我的App"></a>3. 登录成功后，点击<code>我的App</code></h3><p><img src="/images/20160315/Snip20160315_43.png" alt="点击我的App"></p><h3 id="4-点击左上角那个＋号，点击新建-注意：我们是iOS-App开发，不要选Mac-App啦）"><a href="#4-点击左上角那个＋号，点击新建-注意：我们是iOS-App开发，不要选Mac-App啦）" class="headerlink" title="4. 点击左上角那个＋号，点击新建(注意：我们是iOS App开发，不要选Mac App啦）"></a>4. 点击左上角那个<code>＋</code>号，点击新建(注意：我们是<code>iOS App</code>开发，不要选<code>Mac App</code>啦）</h3><p><img src="/images/20160315/Snip20160315_44.png" alt="新建 App"></p><h3 id="5-依次按提示填入对应信息（SKU是公司用于做统计数据之类的id，根据公司需求填写），然后点击创建"><a href="#5-依次按提示填入对应信息（SKU是公司用于做统计数据之类的id，根据公司需求填写），然后点击创建" class="headerlink" title="5. 依次按提示填入对应信息（SKU是公司用于做统计数据之类的id，根据公司需求填写），然后点击创建"></a>5. 依次按提示填入对应信息（<code>SKU</code>是公司用于做统计数据之类的<code>id</code>，根据公司需求填写），然后点击创建</h3><p><img src="/images/20160315/Snip20160315_45.png" alt="填写App信息"></p><p><strong>注意：</strong>如果都填好以后，可能会告诉你，你的<code>App</code>名称已经被占用，那么不好意思，你只能改名了！（而且建议大家起名不要往比较出名的<code>App</code>上靠，否则审核可能会被拒绝）</p><h3 id="6-填写App其它信息"><a href="#6-填写App其它信息" class="headerlink" title="6. 填写App其它信息"></a>6. 填写<code>App</code>其它信息</h3><p><img src="/images/20160315/Snip20160315_46.png" alt=" App信息"></p><h3 id="7-填写价格和销售范围（由于我的开发者账号没有签订纳税合同，所以不能上线收费应用，所以只能暂时免费）"><a href="#7-填写价格和销售范围（由于我的开发者账号没有签订纳税合同，所以不能上线收费应用，所以只能暂时免费）" class="headerlink" title="7. 填写价格和销售范围（由于我的开发者账号没有签订纳税合同，所以不能上线收费应用，所以只能暂时免费）"></a>7. 填写价格和销售范围（由于我的开发者账号没有签订纳税合同，所以不能上线收费应用，所以只能暂时免费）</h3><p><img src="/images/20160315/Snip20160315_47.png" alt="填写价格和销售范围"></p><h3 id="8-依次把不同尺寸的App截图拉入到对应的里面"><a href="#8-依次把不同尺寸的App截图拉入到对应的里面" class="headerlink" title="8. 依次把不同尺寸的App截图拉入到对应的里面"></a>8. 依次把不同尺寸的<code>App</code>截图拉入到对应的里面</h3><p>需要填写不同尺寸的手机屏幕截图（也就是拿不同尺寸的模拟器运行后，挑出至少3页最多5页进行截图然后拖到响应的区里）（在模拟器<code>Command + S</code>就可以保存屏幕截图到桌面了）（注意：如果提示拖进去的图片尺寸不对，则把模拟器弄成<code>100%</code>然后再<code>Command + S</code>) 尺寸参照表在下面</p><p><img src="/images/20160315/Snip20160315_48.png" alt="设置不同尺寸的App截图"></p><p>尺寸参照图：</p><p><img src="/images/20160315/Snip20160315_49.png" alt="尺寸参照图"></p><h3 id="9-填写App简介"><a href="#9-填写App简介" class="headerlink" title="9. 填写App简介"></a>9. 填写<code>App</code>简介</h3><p><img src="/images/20160315/Snip20160315_50.png" alt="填写App简介"></p><h3 id="10-按提示依次输入"><a href="#10-按提示依次输入" class="headerlink" title="10. 按提示依次输入"></a>10. 按提示依次输入</h3><p><img src="/images/20160315/Snip20160315_51.png" alt="按提示依次输入"></p><p><strong>错误提示：</strong>如果上传<code>App</code>图标失败，提示<code>Alpha</code>错误的话，看下面。</p><p>打开你的图标图片，勾掉这个</p><p><img src="/images/20160315/Snip20160315_52.png" alt="勾掉这个"></p><h3 id="11-点击分级后面的编辑，如实填写后，点击完成"><a href="#11-点击分级后面的编辑，如实填写后，点击完成" class="headerlink" title="11. 点击分级后面的编辑，如实填写后，点击完成"></a>11. 点击分级后面的编辑，如实填写后，点击完成</h3><p><img src="/images/20160315/Snip20160315_53.png" alt="分级信息"></p><h3 id="12-填写审核信息"><a href="#12-填写审核信息" class="headerlink" title="12. 填写审核信息"></a>12. 填写审核信息</h3><p><img src="/images/20160315/Snip20160315_54.png" alt="填写审核信息"></p><p>版本发布就是：（然后最下面选择自动发布的话就是如果审核通过，就自动上传到<code>App Store</code>供人下载）</p><h3 id="13-此时这个构建版本还没有生成，我们先把基本信息填写完毕，然后再进入Xcode中把项目打包发送到过来。"><a href="#13-此时这个构建版本还没有生成，我们先把基本信息填写完毕，然后再进入Xcode中把项目打包发送到过来。" class="headerlink" title="13. 此时这个构建版本还没有生成，我们先把基本信息填写完毕，然后再进入Xcode中把项目打包发送到过来。"></a>13. 此时这个构建版本还没有生成，我们先把基本信息填写完毕，然后再进入<code>Xcode</code>中把项目打包发送到过来。</h3><p><strong>注意：</strong>填写完一定要点击右上角的保存。</p><h2 id="七、在Xcode中打包工程"><a href="#七、在Xcode中打包工程" class="headerlink" title="七、在Xcode中打包工程"></a>七、在<code>Xcode</code>中打包工程</h2><p><strong>找到你刚刚下载的发布证书（后缀为<code>.cer</code>）或者<code>p12</code>文件，和PP文件，双击，看起来没反应，但是他们已经加入到你的钥匙串中。</strong></p><h3 id="1-在Xcode中选择iOS-Device-这里不能选择模拟器-，按照下图提示操作"><a href="#1-在Xcode中选择iOS-Device-这里不能选择模拟器-，按照下图提示操作" class="headerlink" title="1. 在Xcode中选择iOS Device(这里不能选择模拟器)，按照下图提示操作"></a>1. 在<code>Xcode</code>中选择<code>iOS Device</code>(这里不能选择模拟器)，按照下图提示操作</h3><p><img src="/images/20160315/Snip20160315_55.png" alt="选择iOS Device"></p><h3 id="2-如果你的应用不支持横屏，把这两个勾去掉"><a href="#2-如果你的应用不支持横屏，把这两个勾去掉" class="headerlink" title="2. 如果你的应用不支持横屏，把这两个勾去掉"></a>2. 如果你的应用不支持横屏，把这两个勾去掉</h3><p><img src="/images/20160315/Snip20160315_56.png" alt="如果你的应用不支持横屏，把这两个勾去掉"></p><h3 id="3-查看版本号和构建版本号"><a href="#3-查看版本号和构建版本号" class="headerlink" title="3. 查看版本号和构建版本号"></a>3. 查看版本号和构建版本号</h3><p><img src="/images/20160315/Snip20160315_57.png" alt="查看版本号和构建版本号"></p><h3 id="4-配置发布证书-ps-截图时选择的证书是错误的，大家注意一下，要选择发布证书"><a href="#4-配置发布证书-ps-截图时选择的证书是错误的，大家注意一下，要选择发布证书" class="headerlink" title="4. 配置发布证书(**ps:**截图时选择的证书是错误的，大家注意一下，要选择发布证书)"></a>4. 配置发布证书(**ps:**截图时选择的证书是错误的，大家注意一下，要选择发布证书)</h3><p><img src="/images/20160315/Snip20160315_58.png" alt="配置发布证书"></p><p><strong>注意：</strong>如果这里没有黄色叹号，代表你的配置没问题，如果有，那就是证书和描述文件不匹配，或者描述文件里刚才选的<code>Bundle</code>和现在的工程的<code>Bundle Identifier</code>不一致，去  <a href="https://develop.apple.com/">https://develop.apple.com</a>  上找到你的描述文件在确认下绑定的<code>bundle Identifier</code>和你工程是不是一样的？</p><p><img src="/images/20160315/Snip20160315_59.png" alt="检查"></p><h3 id="5-将断点、全局断点，僵尸模式等都要去掉。"><a href="#5-将断点、全局断点，僵尸模式等都要去掉。" class="headerlink" title="5. 将断点、全局断点，僵尸模式等都要去掉。"></a>5. 将<strong>断点</strong>、<strong>全局断点</strong>，<strong>僵尸模式</strong>等都要去掉。</h3><p><img src="/images/20160315/Snip20160315_60.png" alt="去掉断点、全局断点"></p><p><img src="/images/20160315/Snip20160315_61.png" alt="Snip20160315_60.png"></p><p><img src="/images/20160315/Snip20160315_62.png" alt="Snip20160315_61.png"></p><p><img src="/images/20160315/Snip20160315_63.png" alt="去掉僵尸模式"></p><h3 id="6-设置Release模式（Debug是测试的，Release是发布用的）"><a href="#6-设置Release模式（Debug是测试的，Release是发布用的）" class="headerlink" title="6. 设置Release模式（Debug是测试的，Release是发布用的）"></a>6. 设置<code>Release</code>模式（<code>Debug</code>是测试的，<code>Release</code>是发布用的）</h3><p><img src="/images/20160315/Snip20160315_64.png" alt="Snip20160315_63.png"></p><p><img src="/images/20160315/Snip20160315_65.png" alt="Snip20160315_64.png"></p><p><img src="/images/20160315/Snip20160315_66.png" alt="Snip20160315_65.png"></p><p><img src="/images/20160315/Snip20160315_67.png" alt="Snip20160315_66.png"></p><h3 id="7-选择Xcode下Product下Archive（专门用于传项目，或者打包项目）"><a href="#7-选择Xcode下Product下Archive（专门用于传项目，或者打包项目）" class="headerlink" title="7. 选择Xcode下Product下Archive（专门用于传项目，或者打包项目）"></a>7. 选择<code>Xcode</code>下<code>Product</code>下<code>Archive</code>（专门用于传项目，或者打包项目）</h3><p><img src="/images/20160315/Snip20160315_68.png" alt="选择Archive"></p><p><img src="/images/20160315/Snip20160315_69.png" alt="Snip20160315_68.png"></p><p><img src="/images/20160315/Snip20160315_70.png" alt="Snip20160315_69.png"></p><h3 id="8-出现下图说明你没有添加开发者账号，点击右下脚Add-按钮就可以添加"><a href="#8-出现下图说明你没有添加开发者账号，点击右下脚Add-按钮就可以添加" class="headerlink" title="8. 出现下图说明你没有添加开发者账号，点击右下脚Add...按钮就可以添加"></a>8. 出现下图说明你没有添加开发者账号，点击右下脚<code>Add...</code>按钮就可以添加</h3><p><img src="/images/20160315/Snip20160315_71.png" alt="没有添加开发者账号"></p><h3 id="9-输入付费的开发者账号"><a href="#9-输入付费的开发者账号" class="headerlink" title="9. 输入付费的开发者账号"></a>9. 输入付费的开发者账号</h3><p><img src="/images/20160315/Snip20160315_72.png" alt="输入开发者账号"></p><p>可能会弹出下面这个界面，如果不弹出，按<code>Command</code>加。</p><p><img src="/images/20160315/Snip20160315_73.png" alt="Snip20160315_72.png"></p><h3 id="10-然后回到Archive-选择已付费的账号-，然后点击Choose"><a href="#10-然后回到Archive-选择已付费的账号-，然后点击Choose" class="headerlink" title="10. 然后回到Archive(选择已付费的账号)，然后点击Choose"></a>10. 然后回到<code>Archive</code>(选择已付费的账号)，然后点击<code>Choose</code></h3><p><img src="/images/20160315/Snip20160315_74.png" alt="选择已付费的账号"></p><p>然后等待</p><p><img src="/images/20160315/Snip20160315_75.png" alt="等待"></p><h3 id="11-选择Upload提交"><a href="#11-选择Upload提交" class="headerlink" title="11. 选择Upload提交"></a>11. 选择<code>Upload</code>提交</h3><p><img src="/images/20160315/Snip20160315_76.png" alt="Upload提交"></p><h3 id="12-如下就代表上传成功，如果出错，请参照iOS-App上传项目遇到的问题"><a href="#12-如下就代表上传成功，如果出错，请参照iOS-App上传项目遇到的问题" class="headerlink" title="12. 如下就代表上传成功，如果出错，请参照iOS App上传项目遇到的问题"></a>12. 如下就代表上传成功，如果出错，请参照<a href="http://blog.developerly.net/2016/03/16/iOS%20App%E4%B8%8A%E4%BC%A0%E9%A1%B9%E7%9B%AE%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/">iOS App上传项目遇到的问题</a></h3><p><img src="/images/20160315/Snip20160315_77.png" alt="上传成功"></p><h3 id="13-返回-Itunes-Connect网站上你自己的App信息中查看一下"><a href="#13-返回-Itunes-Connect网站上你自己的App信息中查看一下" class="headerlink" title="13. 返回﻿﻿Itunes Connect网站上你自己的App信息中查看一下"></a>13. 返回<code>﻿﻿Itunes Connect</code>网站上你自己的<code>App</code>信息中查看一下</h3><p><img src="/images/20160315/Snip20160315_78.png" alt="在App信息中查看"></p><h3 id="14-在这个构建版本这里就可以添加代码"><a href="#14-在这个构建版本这里就可以添加代码" class="headerlink" title="14. 在这个构建版本这里就可以添加代码"></a>14. 在这个构建版本这里就可以添加代码</h3><p><img src="/images/20160315/Snip20160315_79.png" alt="添加代码"></p><p>点击<code>＋</code>号之后选择代码版本</p><p><img src="/images/20160315/Snip20160315_80.png" alt="添加构建版本"></p><h3 id="15-提交以供审核"><a href="#15-提交以供审核" class="headerlink" title="15. 提交以供审核"></a>15. 提交以供审核</h3><p><img src="/images/20160315/Snip20160315_81.png" alt="提交以供审核"></p><h3 id="16-App已经从准备提交，变成正在等待审核状态"><a href="#16-App已经从准备提交，变成正在等待审核状态" class="headerlink" title="16. App已经从准备提交，变成正在等待审核状态"></a>16. <code>App</code>已经从准备提交，变成正在等待审核状态</h3><p><img src="/images/20160315/Snip20160315_82.png" alt="正在等待审核状态"></p><h3 id="17-等待苹果的审核…"><a href="#17-等待苹果的审核…" class="headerlink" title="17. 等待苹果的审核…"></a>17. 等待苹果的审核…</h3><h2 id="八、补充"><a href="#八、补充" class="headerlink" title="八、补充"></a>八、补充</h2><h3 id="构建版本的方法有两种，一种是使用Xcode-上面已经介绍了-，另一种就是使用一个叫Application-Loader这个软件："><a href="#构建版本的方法有两种，一种是使用Xcode-上面已经介绍了-，另一种就是使用一个叫Application-Loader这个软件：" class="headerlink" title="构建版本的方法有两种，一种是使用Xcode(上面已经介绍了)，另一种就是使用一个叫Application Loader这个软件："></a>构建版本的方法有两种，一种是使用<code>Xcode</code>(上面已经介绍了)，另一种就是使用一个叫<code>Application Loader</code>这个软件：</h3><p><img src="/images/20160315/Snip20160315_83.png" alt="Application Loader"></p><ul><li><p>使用Xcode构建版本：<br>上面已经介绍（已经<code>Archive</code>的话，可以在<code>Xcode: Window -&gt; Organizer</code>进入）<br><img src="/images/20160315/Snip20160315_84.png" alt="Upload to App Store..."></p></li><li><p>使用<code>Application Loader</code>构建版本：</p><ul><li>如上图，点击<code>Export...</code>，导出一个<code>ipa</code>文件（**ps:**为了保险起见、让苹果审核顺利一点，这里可以先点击<code>Validate...</code>来验证一下，这里就懒得验证了）</li><li><code>Application Loader</code>下载<code>Xcode</code>的时候就已经下载了（没有的请自行下载），<code>Xcode</code>右键弹出下面界面</li></ul><p> <img src="/images/20160315/Snip20160315_85.png" alt="Open Developer Tool"></p><p> 打开Application Loader（如果没有登录，会提示你登录你的开发者账号）</p><p> <img src="/images/20160315/Snip20160315_86.png" alt="Application Loader"></p><p> 选取你导出的<code>ipa</code>文件（或者双击<code>交付您的应用程序</code>选取<code>ipa</code>文件），之后按提示操作就行，上传完毕没有报错的话，过几分钟左右就可以在<code>iTunes Connect</code>里面就可以看到你上传的这个版本了。</p><p> <img src="/images/20160315/Snip20160315_87.png" alt="构建版本"></p></li></ul><p>补充就这些吧，后面遇到再补充吧！个人建议构建版本使用<code>Application Loader</code>上传，成功率更高！</p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AppStore </tag>
            
            <tag> App上架 </tag>
            
            <tag> 证书 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iOS面试题总结整理（附答案-持续更新）</title>
      <link href="/posts/efd8a2ee.html"/>
      <url>/posts/efd8a2ee.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-多线程的实现方式；"><a href="#1-多线程的实现方式；" class="headerlink" title="1. 多线程的实现方式；"></a>1. 多线程的实现方式；</h2><p><img src="/images/20160313/Snip20160313_1.png" alt="iOS中实现多线程的方案有4种"></p><span id="more"></span><h2 id="2-延迟执行的几种方式；"><a href="#2-延迟执行的几种方式；" class="headerlink" title="2. 延迟执行的几种方式；"></a>2. 延迟执行的几种方式；</h2><ul><li>延迟1秒执行代码</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-(void)delayMethod&#123;</span><br><span class="line">NSLog(@&quot;delayMethodEnd&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>performSelector方法:</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 此方式要求必须在主线程中执行，否则无效。</span><br><span class="line">// 是一种非阻塞的执行方式，暂时未找到取消执行的方法。</span><br><span class="line">[self performSelector:@selector(delayMethod) withObject:nil afterDelay:1.0f];</span><br></pre></td></tr></table></figure><ul><li>定时器：NSTimer;</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 此方式要求必须在主线程中执行，否则无效。</span><br><span class="line">// 是一种非阻塞的执行方式，可以通过`NSTimer`类的`- (void)invalidate;`取消执行。</span><br><span class="line">[NSTimer scheduledTimerWithTimeInterval:1.0f target:self selector:@selector(delayMethod) userInfo:nil repeats:NO];</span><br></pre></td></tr></table></figure><ul><li>sleep方式；</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 此方式在主线程和子线程中均执行。</span><br><span class="line">// 是一种阻塞的执行方式，`建议放到子线程中，以避免卡住界面`，没有找到取消执行的方法。</span><br><span class="line">[NSThread sleepForTimeInterval:1.0f]; [self delayMethod];</span><br></pre></td></tr></table></figure><ul><li>GCD方式<br></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 此方式可以在参数中选择执行的线程。</span><br><span class="line">// 是一种非阻塞的执行方式，</span><br><span class="line">// 没有找到取消执行的方式。</span><br><span class="line">__weak id safeSelf = self;  </span><br><span class="line">dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(1.0 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123;</span><br><span class="line">[safeSelf delayMethod];</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="3-App崩溃的情况有多少种；"><a href="#3-App崩溃的情况有多少种；" class="headerlink" title="3. App崩溃的情况有多少种；"></a>3. App崩溃的情况有多少种；</h2><pre><code>1. 违反操作系统规则：比如启动恢复挂起退出时`watchdog`超时，用户强制退出或者低内存终止。2. 应用程序异常退出。</code></pre><h2 id="4-你使用过Objective-C的运行时编程（Runtime-Programming）么？如果使用过，你用它做了什么？你还能记得你所使用的相关的头文件或者某些方法的名称吗？"><a href="#4-你使用过Objective-C的运行时编程（Runtime-Programming）么？如果使用过，你用它做了什么？你还能记得你所使用的相关的头文件或者某些方法的名称吗？" class="headerlink" title="4. 你使用过Objective-C的运行时编程（Runtime Programming）么？如果使用过，你用它做了什么？你还能记得你所使用的相关的头文件或者某些方法的名称吗？"></a>4. 你使用过Objective-C的运行时编程（Runtime Programming）么？如果使用过，你用它做了什么？你还能记得你所使用的相关的头文件或者某些方法的名称吗？</h2><p>参考答案：</p><p><code>Objecitve-C</code>的重要特性是<code>Runtime</code>（运行时）,在<code>#import &lt;objc/runtime.h&gt;</code> 下能看到相关的方法，用过<code>objc_getClass()</code>和<code>class_copyMethodList()</code>获取过<code>私有API</code>; </p><p> 使用Objecitve-C<br> <code>Method method1 = class_getInstanceMethod(cls, sel1);</code><br> <code>Method method2 = class_getInstanceMethod(cls,  sel2);</code><br> <code>method_exchangeImplementations(method1, method2);</code> </p><p> 代码交换两个方法，在写<code>unit test</code>时使用到。</p><h2 id="5-对于Objective-C，你认为它最大的优点和最大的不足是什么？对于不足之处，现在有没有可用的方法绕过这些不足来实现需求。如果可以的话，你有没有考虑或者实践过重新实现OC的一些功能，如果有，具体会如何做？"><a href="#5-对于Objective-C，你认为它最大的优点和最大的不足是什么？对于不足之处，现在有没有可用的方法绕过这些不足来实现需求。如果可以的话，你有没有考虑或者实践过重新实现OC的一些功能，如果有，具体会如何做？" class="headerlink" title="5. 对于Objective-C，你认为它最大的优点和最大的不足是什么？对于不足之处，现在有没有可用的方法绕过这些不足来实现需求。如果可以的话，你有没有考虑或者实践过重新实现OC的一些功能，如果有，具体会如何做？"></a>5. 对于<code>Objective-C</code>，你认为它最大的优点和最大的不足是什么？对于不足之处，现在有没有可用的方法绕过这些不足来实现需求。如果可以的话，你有没有考虑或者实践过重新实现OC的一些功能，如果有，具体会如何做？</h2><p>参考答案：</p><p>最大的优点是它的运行时特性，不足是没有命名空间，对于命名冲突，可以使用长命名法或特殊前缀解决，如果是引入的第三方库之间的命名冲突，可以使用<code>link</code>命令及<code>flag</code>解决冲突。</p><h2 id="6-iOS中的几种传值问题？"><a href="#6-iOS中的几种传值问题？" class="headerlink" title="6. iOS中的几种传值问题？"></a>6. iOS中的几种传值问题？</h2><ul><li><p>顺传一般是直接传值</p></li><li><p>代理传值</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">A&lt;B-Delegate&gt; // A实现B协议</span><br><span class="line">B // 声明协议和方法 声明代理属性</span><br><span class="line">Delegate-&gt;(methodFromB:(B)b value:(obj)obj)// B声明协议方法</span><br><span class="line">property-weak-deleagte</span><br><span class="line"></span><br><span class="line">// 在A中</span><br><span class="line">B.delegate = A;</span><br><span class="line"></span><br><span class="line">// 当B中发生传值时调用</span><br><span class="line">B</span><br><span class="line">[self.delegate methodFromB:self value:obj]</span><br><span class="line"></span><br><span class="line">// 因为 self.delegate = A</span><br><span class="line">// A中执行定义的协议方法接收到值</span><br><span class="line">-methodFromB:(B)b value:(obj)obj</span><br></pre></td></tr></table></figure></li><li><p>Block传值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">A</span><br><span class="line">// A中实现B的block的代码块</span><br><span class="line">B.block = ^(obj)&#123;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">B // 声明代码块</span><br><span class="line">typedef BBlock</span><br><span class="line">property-block</span><br><span class="line"></span><br><span class="line">// 当B中调用</span><br><span class="line">self.block(obj);</span><br><span class="line">就会调用A中以实现的代码块实现传值</span><br></pre></td></tr></table></figure></li><li><p>通知传值</p></li></ul> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">A中接收通知</span><br><span class="line">NotificationCenter.addobserve(A).name(&quot;NAME&quot;).selector(noti:)</span><br><span class="line">-noti:(noti)noti&#123;</span><br><span class="line">  noti.obj// 接收到值</span><br><span class="line">&#125;</span><br><span class="line">B中发送通知</span><br><span class="line">NotificationCenter.postName(&quot;NAME&quot;).obj(obj)</span><br></pre></td></tr></table></figure><ul><li>单例传值</li></ul> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 用单例中的值更新A的值</span><br><span class="line">A.property = global.singleton.property;</span><br><span class="line">// B中值改变 把值赋给单例</span><br><span class="line">global.singleton.property = B.property;</span><br></pre></td></tr></table></figure><h2 id="7-什么是-ARC-ARC-是为了解决什么问题而诞生的"><a href="#7-什么是-ARC-ARC-是为了解决什么问题而诞生的" class="headerlink" title="7. 什么是 ARC? (ARC 是为了解决什么问题而诞生的?)"></a>7. 什么是 ARC? (ARC 是为了解决什么问题而诞生的?)</h2><p> <code>ARC</code> 是 <code>Automatic Reference Counting</code> 的缩写, 即自动引用计数. 这是苹果在 <code>iOS5</code> 中引入的内存管理机制. <code>Objective-C</code> 和 <code>Swift</code> 使用 <code>ARC</code> 追踪和管理应用的内存使用. 这一机制使得开发者无需键入 <code>retain</code>和 <code>release</code><br>, 这不仅能够降低程序崩溃和内存泄露的风险, 而且可以减少开发者的工作量, 能够大幅度提升程序的<strong>流畅性</strong>和<strong>可预测性</strong>. 但是 <code>ARC</code> 不适用于 <code>Core Foundation</code> 框架中, 仍然需要手动管理内存.</p><h2 id="8-以下-keywords-有什么区别-assign-vs-weak-block-vs-weak"><a href="#8-以下-keywords-有什么区别-assign-vs-weak-block-vs-weak" class="headerlink" title="8. 以下 keywords 有什么区别: assign vs weak , __block vs __weak"></a>8. 以下 keywords 有什么区别: <code>assign</code> vs <code>weak</code> ,<code> __block</code> vs <code>__weak</code></h2><p><code>assign</code> 和 <code>weak</code>是用于在声明属性时, 为属性指定内存管理的语义.</p><ul><li>assign 用于简单的赋值, 不改变属性的引用计数, 用于 Objective-C 中的 <code>NSInteger</code> , <code>CGFloat</code> 以及 C 语言中 <code>int</code> , <code>float</code> , <code>double</code> 等数据类型.</li><li><code>weak</code> 用于对象类型, 由于 <code>weak</code> 同样不改变对象的引用计数且不持有对象实例, 当该对象废弃时, 该弱引用自动失效并且被赋值为 nil , 所以它可以用于避免两个强引用产生的<strong>循环引用</strong>导致内存无法释放的问题.</li></ul><p><code>__block</code> 和 <code>__weak</code> 之间的却是确实极大的, 不过它们都用于修饰变量.</p><ul><li>前者用于指明当前声明的变量在被 block 捕获之后, 可以在 block 中改变变量的值. 因为在 block 声明的同时会截获该 block 所使用的全部自动变量的值, 而这些值只在 block 中<strong>只具有”使用权”而不具有”修改权”</strong>. 而 __block 说明符就为 block 提供了变量的修改权. </li><li>后者是<strong>所有权修饰符</strong>, 什么是所有权修饰符? 这里涉及到另一个问题, 因为在 ARC 有效时, id 类型和对象类型同 C 语言中的其他类型不同, 必须附加所有权修饰符. 所有权修饰符一种有 4 种:</li><li>__strong</li><li>__weak</li><li>__unsafe_unretained</li><li>__autorelease</li><li><code>__weak</code> 与 <code>weak</code> 的区别只在于, 前者用于变量的声明, 而后者用于属性的声明.</li></ul><h2 id="9-block-在-ARC-和非-ARC-下含义一样吗？"><a href="#9-block-在-ARC-和非-ARC-下含义一样吗？" class="headerlink" title="9. __block 在 ARC 和非 ARC 下含义一样吗？"></a>9. <code>__block</code> 在 ARC 和非 ARC 下含义一样吗？</h2><p><code>__block</code> <strong>在 ARC 下捕获的变量会被 block retain</strong>, 这样可能导致循环引用, 所以必须要使用弱引用才能解决该问题.<br>而在非 ARC 下, 可以直接使用 <code>__block</code> 说明符修饰变量, 因为在非 ARC 下, <code>block</code> 不会 <code>retain</code> 捕获的变量.</p><h2 id="10-viewWillLayoutSubviews-的作用是什么"><a href="#10-viewWillLayoutSubviews-的作用是什么" class="headerlink" title="10. viewWillLayoutSubviews 的作用是什么?"></a>10. <code>viewWillLayoutSubviews</code> 的作用是什么?</h2><p> <code>viewWillLayoutSubviews</code> 方法会在视图的 <code>bounds</code> 改变时, 视图会调整子视图的位置, 我们可以在视图控制器中覆写这个方法在视图放置子视图前做出改变, 当屏幕的方向改变时, 这个方法会被调用.</p><h2 id="11-SDWebImage-里面给-UIImageView-加载图片的逻辑是什么样的"><a href="#11-SDWebImage-里面给-UIImageView-加载图片的逻辑是什么样的" class="headerlink" title="11. SDWebImage 里面给 UIImageView 加载图片的逻辑是什么样的?"></a>11. <code>SDWebImage</code> 里面给 <code>UIImageView</code> 加载图片的逻辑是什么样的?</h2><p>我曾经阅读过 <code>SDWebImage</code> 的源代码, 就在这里对如何给 <code>UIImageView</code> 加载图片做一个总结吧, <code>SDWebImage</code> 中为 <code>UIView</code> 提供了一个分类叫做 <code>WebCache</code>, 这个分类中有一个最常用的接口, <code>sd_setImageWithURL:placeholderImage:</code> , 这个分类同时提供了很多类似的方法, 这些方法最终会调用一个同时具有 <code>option</code> <code>progressBlock</code> <code>completionBlock</code>的方法, 而在这个类最终被调用的方法首先会检查是否传入了 <code>placeholderImage</code> 以及对应的参数, 并设置 <code>placeholderImage</code> .<br>然后会获取 <code>SDWebImageManager</code> 中的单例调用一个 <code>downloadImageWithURL:...</code> 的方法来获取图片, 而这个 manager 获取图片的过程有大体上分为两部分, 它首先会在 <code>SDWebImageCache</code> 中寻找图片是否有对应的缓存, 它会以 <code>url</code> 作为数据的索引先在内存中寻找是否有对应的缓存, 如果缓存未命中就会在磁盘中利用 <code>MD5</code> 处理过的 <code>key</code> 来继续查询对应的数据, 如果找到了, 就会把磁盘中的缓存备份到内存中.<br>然而, 假设我们在内存和磁盘缓存中都没有命中, 那么 manager 就会调用它持有的一  个 <code>SDWebImageDownloader</code> 对象的方法 <code>downloadImageWithURL:...</code> 来下载图片, 这个方法会在执行的过程中调用另一个方法 <code>addProgressCallback:andCompletedBlock:fotURL:createCallback:</code> 来存储下载过程中和下载完成的回调, 当回调块是第一次添加的时候, 方法会实例化一个 <code>NSMutableURLRequest</code> 和 <code>SDWebImageDownloaderOperation</code> , 并将后者加入 downloader 持有的下载队列开始图片的异步下载.<br>而在图片下载完成之后, 就会在主线程设置 <code>image</code>, 完成整个图像的异步下载和配置.</p><h2 id="12-你一般是怎么用Instruments的？（工作经验的问题，没必要所有都答）"><a href="#12-你一般是怎么用Instruments的？（工作经验的问题，没必要所有都答）" class="headerlink" title="12. 你一般是怎么用Instruments的？（工作经验的问题，没必要所有都答）"></a>12. 你一般是怎么用<code>Instruments</code>的？（工作经验的问题，没必要所有都答）</h2><p><strong>参考答案：</strong></p><ul><li>使用<code>Allocations</code>来检测内存和堆栈信息</li><li>使用<code>Leaks</code>检测内存的使用情况，包括内存泄露问题</li><li>使用<code>Zombies</code>来检测过早释放的僵尸对象，通过它可以检测出在哪里崩溃的。</li><li>使用<code>Time Profiler</code>来检测<code>CPU</code>内存使用情况，性能分析</li></ul><h2 id="13-performSelector-withObject-afterDelay-内部大概是怎么实现的，有什么注意事项么？"><a href="#13-performSelector-withObject-afterDelay-内部大概是怎么实现的，有什么注意事项么？" class="headerlink" title="13. performSelector:withObject:afterDelay: 内部大概是怎么实现的，有什么注意事项么？"></a>13. <code>performSelector:withObject:afterDelay: </code>内部大概是怎么实现的，有什么注意事项么？</h2><ul><li>创建一个定时器,时间结束后系统会使用runtime通过方法名称(Selector本质就是方法名称)去方法列表中找到对应的方法实现并调用方法</li></ul><p> 注意事项</p><ul><li>调用<code>performSelector:withObject:afterDelay:</code>方法时,先判断希望调用的方法是否存在<code>respondsToSelector:</code></li><li>这个方法是异步方法,必须在主线程调用,在子线程调用永远不会调用到想调用的方法</li></ul><h2 id="14-有哪些常见的-Crash-场景？"><a href="#14-有哪些常见的-Crash-场景？" class="headerlink" title="14. 有哪些常见的 Crash 场景？"></a>14. 有哪些常见的 <code>Crash</code> 场景？</h2><ul><li>访问了僵尸对象</li><li>访问了不存在的方法</li><li>数组越界</li><li>在定时器下一次回调前将定时器释放,会Crash</li></ul><h2 id="持续更新…"><a href="#持续更新…" class="headerlink" title="持续更新…"></a>持续更新…</h2>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> Objective-C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>点击状态栏，滚动视图返回顶部的实现原理</title>
      <link href="/posts/a330e4e0.html"/>
      <url>/posts/a330e4e0.html</url>
      
        <content type="html"><![CDATA[<h1 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h1><p> 在iOS开发中，我们常常看到好多应用都有这样一个效果，如果一个应用当前页是是一个滚动视图，当用户点击状态栏的时候，滚动视图会自动的返回内容的最顶部。<br>其实这个功能是<code>UIScrollView</code>自带的，不需要我们手动去实现，只需要设置<code>self.scrollView.scrollsToTop = YES</code>即可（<code>scrollsToTop</code>默认为<code>YES</code>）。但是这个属性有一个前提是窗口下必须只有一个可滚动的<code>View</code>才有效果。</p><span id="more"></span><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// When the user taps the status bar, the scroll view beneath the touch which is closest to the status bar will be scrolled to top, but only if its `scrollsToTop` property is YES, its delegate does not return NO from `shouldScrollViewScrollToTop`, and it is not already at the top.</span><br><span class="line">// On iPhone, we execute this gesture only if there&#x27;s one on-screen scroll view with `scrollsToTop` == YES. If more than one is found, none will be scrolled.</span><br></pre></td></tr></table></figure><p>在实际应用中，我们可能会有多个<code>scrollView</code>（包含<code>UITableView/UICollectionView</code>），如网易新闻、爱奇艺，腾讯视频等等应用，这时候，系统默认的点击状态栏返回到顶部效果就会失效，原因是当前<code>window</code>下多个<code>scrollView</code>的<code>scrollsToTop</code>属性的值都是<code>YES</code>,系统不知道该让哪一个<code>scrollView</code>滚动到顶部，所以就什么也不干了。如果还要让当前视图滚回顶部，只需要将除了当前显示的其它<code>scrollView</code>的<code>scrollsToTop</code>属性设置成<code>NO</code>就行。</p><p>但是今天要讲的是应网友要求，讲一下自定义控件来实现此功能。就是《<a href="https://github.com/DeveloperLY/LYTopWindow">LYTopWindow</a>》实现原理。</p><h1 id="二、基本思路"><a href="#二、基本思路" class="headerlink" title="二、基本思路"></a>二、基本思路</h1><ol><li>获取当状态栏的点击事件</li><li>取得当前<code>window</code>上显示的<code>scrollView</code></li><li>控制<code>scrollView</code>的偏移量，让其滚动到顶部</li></ol><h1 id="三、实现步骤"><a href="#三、实现步骤" class="headerlink" title="三、实现步骤"></a>三、实现步骤</h1><p>新建一个空白项目，我们可以查看应用结构可以知道，状态栏是独立出来的，并不在window上<br><img src="/images/20160227/Snip20160227_1.png" alt="空白应用"></p><p>所以我们不能拿到状态栏直接操作，那么就需要自定义一个控件盖在状态栏上面，用来拦截状态栏的点击事件。</p><h3 id="一、添加窗口"><a href="#一、添加窗口" class="headerlink" title="一、添加窗口"></a>一、添加窗口</h3><p>由于添加普通的控件都不能盖在状态栏上面，所有要新建一个普通的<code>window</code>（<code>keyWindow</code>只能有一个）盖到状态栏的上面。</p><ul><li>在<code>AppDelegate</code>创建一个新的窗口,从<code>iOS9.0</code>开始，程序启动结束时的窗口都必须设置<code>rootViewController</code>。否则会报以下错误：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Application windows are expected to have a root view controller at the end of application launch</span><br></pre></td></tr></table></figure><p>这里可以通过<code>dispatch_after</code>来给添加窗口一个延时就可以不设置根控制器而不会报错</p><ul><li><code>UIWindow</code>的显示不需要添加到其它控件上，只需要将<code>hidden</code>设置成<code>NO</code>就行。</li><li>要想让自定义窗口盖在状态栏的上面还要设置窗口的级别<code>windowLevel</code>，窗口的级别有三种，分别是<code>UIWindowLevelAlert &gt; UIWindowLevelStatusBar &gt; UIWindowLevelNormal</code>，级别越高就越显示在顶部，如果级别一样，那么后创建添加的显示在顶部。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">static UIWindow *topWindow_;</span><br><span class="line">-(BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions &#123;</span><br><span class="line">dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(0.5 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        topWindow_ = [[UIWindow alloc] init];</span><br><span class="line">        topWindow_.frame = [UIApplication sharedApplication].statusBarFrame;</span><br><span class="line">        topWindow_.backgroundColor = [UIColor clearColor];</span><br><span class="line">        topWindow_.hidden = NO;</span><br><span class="line">        topWindow_.windowLevel = UIWindowLevelAlert;</span><br><span class="line">    &#125;);</span><br><span class="line">    return YES;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在给<code>topWindow</code>添加一个手势监听点击事件就可以拦截到状态栏的点击事件了。<br>但是，这样写会有一个Bug,如果旋转屏幕的话，<code>window</code>上的添加的<code>View</code>的<code>frame</code>不会跟着屏幕旋转而改变，就会不正确。</p><ul><li>如果需要屏幕旋转的话，必须要给<code>UIWindwo</code>设置<code>rootViewController</code>；</li><li>Bug产生的原因是<code>Autoresizing</code>的影响，在旋转的屏幕时，窗口的<code>View</code>宽高被拉伸而造成<code>frame</code>不正确，这时只需要设置一下<code>View</code>跟随窗口的变化而变化即可。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">topWindow_.rootViewController.view.autoresizingMask = UIViewAutoresizingFlexibleWidth;</span><br></pre></td></tr></table></figure><p>居然这里已经设置了<code>rootViewController</code>，那么就不需要<code>dispatch_after</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">static UIWindow *topWindow_;</span><br><span class="line">-(BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions &#123;</span><br><span class="line">    topWindow_ = [[UIWindow alloc] init];</span><br><span class="line">    topWindow_.frame = [UIApplication sharedApplication].statusBarFrame;</span><br><span class="line">    topWindow_.backgroundColor = [UIColor clearColor];</span><br><span class="line">    topWindow_.hidden = NO;</span><br><span class="line">    topWindow_.windowLevel = UIWindowLevelAlert;</span><br><span class="line">    [topWindow_ addGestureRecognizer:[[UITapGestureRecognizer alloc] initWithTarget:self action:@selector(topWindowClick)]];</span><br><span class="line">    return YES;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二、监听顶部窗口点击，实现当前滚动视图滚回顶部"><a href="#二、监听顶部窗口点击，实现当前滚动视图滚回顶部" class="headerlink" title="二、监听顶部窗口点击，实现当前滚动视图滚回顶部"></a>二、监听顶部窗口点击，实现当前滚动视图滚回顶部</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/** * 监听顶部窗口点击 */</span><br><span class="line">+ (void)topWindowClick &#123;</span><br><span class="line">    UIWindow *keyWindow = [UIApplication sharedApplication].keyWindow;</span><br><span class="line">    [self searchAllScrollViewsInView:keyWindow];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查找当前<code>keyWindow</code>上的滚动视图,如果跟<code>keyWindow</code>重叠，就让其滚动到顶部</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> *  查找view中的所有scrollView</span><br><span class="line"> */</span><br><span class="line">- (void)searchAllScrollViewsInView:(UIView *)view &#123;</span><br><span class="line">    // 如果不在UIWindow矩形框里面，就直接返回</span><br><span class="line">    // view和UIWindow没有重叠，就直接返回</span><br><span class="line">    if (![view intersectWithView:nil]) return;</span><br><span class="line">    </span><br><span class="line">    for (UIView *subview in view.subviews) &#123;</span><br><span class="line">        [self searchAllScrollViewsInView:subview];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 如果不是UIScrollView, 直接返回</span><br><span class="line">    if (![view isKindOfClass:[UIScrollView class]]) return;</span><br><span class="line">    </span><br><span class="line">    UIScrollView *scrollView = (UIScrollView *)view;</span><br><span class="line">    </span><br><span class="line">    // 让UIScrollView滚动到最前面</span><br><span class="line">    CGPoint offset = scrollView.contentOffset;</span><br><span class="line">    offset.y = - scrollView.contentInset.top;</span><br><span class="line">    [scrollView setContentOffset:offset animated:YES];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>LYTopWindow的基本实现原理就是这样了，如果想看了解基本实现步骤可以查看LYTopWindow的源代码：<a href="https://github.com/DeveloperLY/LYTopWindow">https://github.com/DeveloperLY/LYTopWindow</a> 。</p><h3 id="三、补充"><a href="#三、补充" class="headerlink" title="三、补充"></a>三、补充</h3><p>如果使用了自定义控件实现了点击状态栏滚动视图自动滚回顶部，那么控制器的这两个方法会失效：</p><ol><li>控制器的<code>- (BOOL)prefersStatusBarHidden</code>方法决定状态栏的可见性</li><li>控制器的<code>- (UIStatusBarStyle)preferredStatusBarStyle</code>方法决定状态栏的样式</li></ol><p>原因就是状态栏的样式\可见性，由最顶层（盖在最上面）<code>window</code>的控制器来决定<br>所以如果使用了<a href="https://github.com/DeveloperLY/LYTopWindow">LYTopWindwo</a>框架的，如果要控制状态栏的样式和可见性可以使用下面的代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 可见性</span><br><span class="line">[LYTopWindow sharedTopWindow].statusBarHidden = NO;</span><br><span class="line">[LYTopWindow sharedTopWindow].statusBarHidden = YES;</span><br><span class="line">   </span><br><span class="line">// 样式</span><br><span class="line">[LYTopWindow sharedTopWindow].statusBarStyle = UIStatusBarStyleDefault;</span><br><span class="line">[LYTopWindow sharedTopWindow].statusBarStyle = UIStatusBarStyleLightContent;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> UIScrollView </tag>
            
            <tag> LYTopWindwo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一行代码集成点击状态栏，滚动视图当前内容滚动到顶部</title>
      <link href="/posts/b863f5ac.html"/>
      <url>/posts/b863f5ac.html</url>
      
        <content type="html"><![CDATA[<h1 id="只有一个ScrollView的时候"><a href="#只有一个ScrollView的时候" class="headerlink" title="只有一个ScrollView的时候"></a>只有一个ScrollView的时候</h1><p>我们在使用App的时候，经常会看到这样的效果，当我们点击状态栏的时候，我们已经滚动过的内容，会自动的滚回顶部，例如：设置界面:</p><p><img src="/images/20160222/Gif20160222_01.gif" alt="设置界面效果"></p><span id="more"></span><p>其实这个功能是系统默认实现的，不需要自己写代码。<br>当点击状态栏的时候自动滚回顶部是因为<code>UIScrollView</code>的<code>scrollsToTop</code>的属性为<code>YSE</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@property(nonatomic) BOOL  scrollsToTop __TVOS_PROHIBITED;          // default is YES.</span><br></pre></td></tr></table></figure><p>居然系统已经实现了这个功能，那么为什么还要自己实现呢？<br>这个是因为，系统实现的是有缺陷的。</p><h1 id="当ScrollView超过一个的时候"><a href="#当ScrollView超过一个的时候" class="headerlink" title="当ScrollView超过一个的时候"></a>当ScrollView超过一个的时候</h1><p>下面是苹果对scrollsToTop属性的解析说明</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// When the user taps the status bar, the scroll view beneath the touch which is closest to the status bar will be scrolled to top, but only if its `scrollsToTop` property is YES, its delegate does not return NO from `shouldScrollViewScrollToTop`, and it is not already at the top.</span><br><span class="line">// On iPhone, we execute this gesture only if there&#x27;s one on-screen scroll view with `scrollsToTop` == YES. If more than one is found, none will be scrolled.</span><br></pre></td></tr></table></figure><p>那就是当前视图下，超过一个ScrollView的时候，即使你将scrollsToTop的值设置为YES，但是在点击状态栏的时候，不会有一个ScrollView会滚动到顶部。<br><img src="/images/20160222/Gif20160222_02.gif" alt="多个ScrollView的时候"></p><p>这个时候，如果我们需要这个功能，那么就要我们手动实现了。<br>针对这个，我封装了一个小框架“<a href="https://github.com/DeveloperLY/LYTopWindow">一行代码完成“点击状态栏滚动视图当前内容滚动到顶部</a>”，框架集成了CocoaPods，方便使用，一行代码可以实现这个小功能。</p><h1 id="使用LYTopWindow"><a href="#使用LYTopWindow" class="headerlink" title="使用LYTopWindow"></a>使用LYTopWindow</h1><h3 id="第一步：使用CocoaPods导入LYTopWindow"><a href="#第一步：使用CocoaPods导入LYTopWindow" class="headerlink" title="第一步：使用CocoaPods导入LYTopWindow"></a>第一步：使用CocoaPods导入LYTopWindow</h3><p>在 <code>Podfile</code> 中进行如下导入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod &#x27;LYTopWindow&#x27;</span><br></pre></td></tr></table></figure><p>然后使用 <code>cocoaPods</code> 进行安装：</p><p>如果尚未安装<code>CocoaPods</code>, 运行以下命令进行安装:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gem install cocoapods</span><br></pre></td></tr></table></figure><p>安装成功后就可以安装依赖了：</p><p>建议使用如下方式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 禁止升级CocoaPods的spec仓库，否则会卡在 Analyzing dependencies ，非常慢 </span><br><span class="line">pod update --verbose --no-repo-update</span><br></pre></td></tr></table></figure><p>如果提示找不到库，则可去掉<code>--no-repo-update</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod update</span><br></pre></td></tr></table></figure><h3 id="第二步：集成点击状态栏当前内容滚动到顶部"><a href="#第二步：集成点击状态栏当前内容滚动到顶部" class="headerlink" title="第二步：集成点击状态栏当前内容滚动到顶部"></a>第二步：集成点击状态栏当前内容滚动到顶部</h3><p>导入头文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#import &lt;LYTopWindow.h&gt;</span><br></pre></td></tr></table></figure><p>在AppDelegate.m中方法application:didFinishLaunchingWithOptions:中添加以下代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[[LYTopWindow sharedTopWindow] setClickStatusBarBlock:^&#123;</span><br><span class="line">// 让keyWindow上的ScrollView滚动到顶部</span><br><span class="line">[[LYTopWindow sharedTopWindow] searchAllScrollViewsInView:[UIApplication sharedApplication].keyWindow];</span><br><span class="line">        </span><br><span class="line">// 如果需要实现点击状态栏，实现其他功能，可用在这里编写功能代码</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><p>注意：如果需要实现其他功能效果，可以将这句代码替换成其他需要的代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[LYTopWindow sharedTopWindow] searchAllScrollViewsInView:[UIApplication sharedApplication].keyWindow];</span><br></pre></td></tr></table></figure><p><img src="/images/20160222/Gif20160222_03.gif" alt="使用LYTopWindow后的效果图"></p><p>框架里面有个小Demo，可以自行实验，欢迎Issues<br><a href="https://github.com/DeveloperLY/LYTopWindow">LYTopWindow</a>地址：<a href="https://github.com/DeveloperLY/LYTopWindow">https://github.com/DeveloperLY/LYTopWindow</a><br>如果想了解LYTopWindow的实现原理，可以查看我的另一篇文章《<a href="http://www.jianshu.com/p/b5d01f760d7b">点击状态栏，滚动视图返回顶部的实现</a>》</p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> UIScrollView </tag>
            
            <tag> scrollsToTop </tag>
            
            <tag> LYTopWindow </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>为Xcode添加删除当前行、复制当前行快捷键</title>
      <link href="/posts/852ff423.html"/>
      <url>/posts/852ff423.html</url>
      
        <content type="html"><![CDATA[<p>之前在做JAVA开发时,使用eclipse过程中,用的最多也是特喜欢的就是删除当前行和复制当前行的快捷键。然而在转向iOS开发时,Xcode是不支持这两个快捷键的,一次偶然发现有个小窍门可以为Xcode来添加这两个快捷键。</p><span id="more"></span><h2 id="修改权限"><a href="#修改权限" class="headerlink" title="修改权限"></a>修改权限</h2><ul><li>修改<code>Xcode</code>里快捷键的配置文件<code>(plist)</code>的权限,在终端中输入下面两条命令</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo chmod 666 /Applications/Xcode.app/Contents/Frameworks/IDEKit.framework/Resources/IDETextKeyBindingSet.plist</span><br><span class="line">sudo chmod 777 /Applications/Xcode.app/Contents/Frameworks/IDEKit.framework/Resources/</span><br></pre></td></tr></table></figure><h2 id="添加快捷方式"><a href="#添加快捷方式" class="headerlink" title="添加快捷方式"></a>添加快捷方式</h2><ul><li>权限修改完成后,在终端中输入下面的命令,打开<code>plist</code>文件修改(默认是Xcode打开)</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">open /Applications/Xcode.app/Contents/Frameworks/IDEKit.framework/Resources/IDETextKeyBindingSet.plist</span><br></pre></td></tr></table></figure><h3 id="添加删除当前行"><a href="#添加删除当前行" class="headerlink" title="添加删除当前行"></a>添加删除当前行</h3><ul><li>找到<code>root</code>下的<code>Deletions</code>,在<code>Deletions</code>下添加一个item:</li><li>key:<code>Delete Current Line</code></li><li>value:<code>deleteToBeginningOfLine:, moveToEndOfLine:, deleteToBeginningOfLine:, deleteBackward:, moveDown:, moveToBeginningOfLine:</code></li></ul><h3 id="添加复制当前行"><a href="#添加复制当前行" class="headerlink" title="添加复制当前行"></a>添加复制当前行</h3><ul><li>在<code>Insertions and Indentations</code>下添加两个item:</li><li>key:<code>Duplicate Current Line</code> value:<code>selectLine:, copy:, moveToEndOfLine:, insertNewline:, paste:, deleteBackward:</code></li><li>key:<code>Insert Line Under</code>  value:<code>moveToEndOfLine:, insertNewline:</code></li><li>如图<br><img src="/images/20160118/Snip20160118_1.png" alt="Snip20160118_1.png"></li></ul><h2 id="设置快捷键"><a href="#设置快捷键" class="headerlink" title="设置快捷键"></a>设置快捷键</h2><ul><li>最重要的部分来了, 重启<code>Xcode</code>, 然后在<code>preferences</code>里找到<code>Key Bindings</code>,在搜索框中输入<code>current</code>,可以快速定位到<code>Delete Current Line</code>和<code>Duplicate Current Line</code>两个选项,只要设置自己喜欢的快捷键即可。</li><li>如图:<br><img src="/images/20160118/Snip20160118_2.png" alt="Snip20160118_2.png"></li></ul>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> Xcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>吱一声</title>
      <link href="/posts/9e73c278.html"/>
      <url>/posts/9e73c278.html</url>
      
        <content type="html"><![CDATA[<p>想我也不是那种写博客的人(很久以前<a href="http://my.csdn.net/u011619223?locationNum=0&fps=1">CSDN</a>地址)，但作为一枚程序猿没有个自己的博客，貌似很OUT~~。</p><p>博客是部署到GitHub上的，用的是Hexo，很方便就搭起来了~</p><p>只是存在的时间有多长，就不得而知啦~~</p><span id="more"></span>]]></content>
      
      
      <categories>
          
          <category> 吐槽 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 吐槽 </tag>
            
            <tag> GitHub </tag>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
